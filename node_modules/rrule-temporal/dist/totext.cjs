"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/totext.ts
var totext_exports = {};
__export(totext_exports, {
  toText: () => toText
});
module.exports = __toCommonJS(totext_exports);

// src/index.ts
var import_polyfill = require("@js-temporal/polyfill");
function isIcsOpts(opts) {
  return typeof opts.rruleString === "string";
}
function unfoldLine(foldedLine) {
  return foldedLine.replace(/\r?\n[ \t]/g, "");
}
function parseIcsDateTime(dateStr, tzid, valueType) {
  const isDate = valueType === "DATE" || !dateStr.includes("T");
  const isoDate = `${dateStr.slice(0, 4)}-${dateStr.slice(4, 6)}-${dateStr.slice(6, 8)}`;
  if (isDate) {
    return import_polyfill.Temporal.PlainDate.from(isoDate).toZonedDateTime({ timeZone: tzid });
  }
  if (dateStr.endsWith("Z")) {
    const iso = `${isoDate}T${dateStr.slice(9, 15)}Z`;
    return import_polyfill.Temporal.Instant.from(iso).toZonedDateTimeISO(tzid || "UTC");
  } else {
    const iso = `${isoDate}T${dateStr.slice(9)}`;
    return import_polyfill.Temporal.PlainDateTime.from(iso).toZonedDateTime(tzid);
  }
}
function parseDateLines(lines, linePrefix, defaultTzid) {
  const dates = [];
  const regex = new RegExp(`^${linePrefix}(?:;VALUE=([^;]+))?(?:;TZID=([^:]+))?:(.+)`, "i");
  for (const line of lines) {
    const match = line.match(regex);
    if (match) {
      const [, valueType, tzid, dateValuesStr] = match;
      const timezone = tzid || defaultTzid;
      const dateValues = dateValuesStr.split(",");
      dates.push(...dateValues.map((dateValue) => parseIcsDateTime(dateValue, timezone, valueType)));
    }
  }
  return dates;
}
function parseNumberArray(val, sort = false) {
  const arr = val.split(",").map((n) => parseInt(n, 10));
  if (sort) {
    return arr.sort((a, b) => a - b);
  }
  return arr;
}
function parseByMonthArray(val) {
  return val.split(",").map((tok) => {
    const t = tok.trim();
    if (/^\d+L$/i.test(t)) return t.toUpperCase();
    const n = parseInt(t, 10);
    return Number.isFinite(n) ? n : t;
  });
}
function parseRRuleString(input, targetTimezone, dtstart) {
  var _a, _b, _c, _d, _e;
  const unfoldedInput = unfoldLine(input).trim();
  let parsedDtstart;
  let tzid = targetTimezone;
  let rruleLine;
  let exDate = [];
  let rDate = [];
  if (/^DTSTART/im.test(unfoldedInput)) {
    const lines = unfoldedInput.split(/\s+/);
    const dtLine = lines.find((line) => line.match(/^DTSTART/i));
    const rrLine = lines.find((line) => line.match(/^RRULE:/i));
    const exLines = lines.filter((line) => line.match(/^EXDATE/i));
    const rLines = lines.filter((line) => line.match(/^RDATE/i));
    const dtMatch = dtLine.match(/DTSTART(?:;VALUE=([^;]+))?(?:;TZID=([^:]+))?:(.+)/i);
    if (!dtMatch) throw new Error("Invalid DTSTART in ICS snippet");
    const [, valueType, dtTzid, dtValue] = dtMatch;
    const effectiveTzid = (_b = (_a = dtTzid != null ? dtTzid : targetTimezone) != null ? _a : tzid) != null ? _b : "UTC";
    parsedDtstart = parseIcsDateTime(dtValue, effectiveTzid, valueType);
    tzid = (_e = (_d = (_c = dtTzid != null ? dtTzid : parsedDtstart.timeZoneId) != null ? _c : targetTimezone) != null ? _d : tzid) != null ? _e : "UTC";
    rruleLine = rrLine;
    exDate = parseDateLines(exLines, "EXDATE", tzid != null ? tzid : "UTC");
    rDate = parseDateLines(rLines, "RDATE", tzid != null ? tzid : "UTC");
  } else {
    parsedDtstart = dtstart;
    rruleLine = unfoldedInput;
    if (parsedDtstart) {
      tzid = parsedDtstart.timeZoneId;
    }
  }
  const parts = rruleLine ? rruleLine.replace(/^RRULE:/i, "").split(";") : [];
  const opts = {
    dtstart: parsedDtstart,
    tzid,
    exDate: exDate.length > 0 ? exDate : void 0,
    rDate: rDate.length > 0 ? rDate : void 0
  };
  let pendingSkip;
  for (const part of parts) {
    const [key, val] = part.split("=");
    if (!key) continue;
    switch (key.toUpperCase()) {
      case "RSCALE":
        if (val) {
          opts.rscale = val.toUpperCase();
          if (pendingSkip && !opts.skip) {
            opts.skip = pendingSkip;
            pendingSkip = void 0;
          }
        }
        break;
      case "SKIP": {
        const v = (val || "").toUpperCase();
        if (!["OMIT", "BACKWARD", "FORWARD"].includes(v)) {
          throw new Error(`Invalid SKIP value: ${val}`);
        }
        if (opts.rscale) {
          opts.skip = v;
        } else {
          pendingSkip = v;
        }
        break;
      }
      case "FREQ":
        opts.freq = val.toUpperCase();
        break;
      case "INTERVAL":
        opts.interval = parseInt(val, 10);
        break;
      case "COUNT":
        opts.count = parseInt(val, 10);
        break;
      case "UNTIL": {
        opts.until = parseIcsDateTime(val, tzid || "UTC");
        if (!val.endsWith("Z") && tzid !== "UTC") {
          throw new Error("UNTIL rule part MUST always be specified as a date with UTC time");
        }
        break;
      }
      case "BYHOUR":
        opts.byHour = parseNumberArray(val, true);
        break;
      case "BYMINUTE":
        opts.byMinute = parseNumberArray(val, true);
        break;
      case "BYSECOND":
        opts.bySecond = parseNumberArray(val, true);
        break;
      case "BYDAY":
        opts.byDay = val.split(",");
        break;
      case "BYMONTH":
        opts.byMonth = parseByMonthArray(val);
        break;
      case "BYMONTHDAY":
        opts.byMonthDay = parseNumberArray(val);
        break;
      case "BYYEARDAY":
        opts.byYearDay = parseNumberArray(val);
        break;
      case "BYWEEKNO":
        opts.byWeekNo = parseNumberArray(val);
        break;
      case "BYSETPOS":
        opts.bySetPos = parseNumberArray(val);
        break;
      case "WKST":
        opts.wkst = val;
        break;
    }
  }
  if (pendingSkip && !opts.rscale) {
    throw new Error("SKIP MUST NOT be present unless RSCALE is present");
  }
  if (pendingSkip && opts.rscale && !opts.skip) {
    opts.skip = pendingSkip;
  }
  return opts;
}
var _RRuleTemporal = class _RRuleTemporal {
  constructor(params) {
    var _a, _b, _c, _d, _e, _f, _g;
    let manual;
    if (isIcsOpts(params)) {
      const parsed = parseRRuleString(params.rruleString, params.tzid, params.dtstart);
      if (!parsed.dtstart) {
        throw new Error("dtstart is required - provide it either in rruleString or as a separate parameter");
      }
      this.tzid = (_b = (_a = parsed.tzid) != null ? _a : params.tzid) != null ? _b : "UTC";
      this.originalDtstart = parsed.dtstart;
      manual = __spreadProps(__spreadValues({}, parsed), {
        // Allow explicit COUNT/UNTIL overrides when omitted from the RRULE string
        count: (_c = params.count) != null ? _c : parsed.count,
        until: (_d = params.until) != null ? _d : parsed.until,
        maxIterations: params.maxIterations,
        includeDtstart: params.includeDtstart,
        tzid: this.tzid
      });
    } else {
      manual = __spreadValues({}, params);
      if (typeof manual.dtstart === "string") {
        throw new Error("Manual dtstart must be a ZonedDateTime");
      }
      manual.tzid = manual.tzid || manual.dtstart.timeZoneId;
      this.tzid = manual.tzid;
      this.originalDtstart = manual.dtstart;
    }
    if (!manual.freq) throw new Error("RRULE must include FREQ");
    manual.interval = (_e = manual.interval) != null ? _e : 1;
    if (manual.interval <= 0) {
      throw new Error("Cannot create RRule: interval must be greater than 0");
    }
    if (manual.until && !(manual.until instanceof import_polyfill.Temporal.ZonedDateTime)) {
      throw new Error("Manual until must be a ZonedDateTime");
    }
    this.opts = this.sanitizeOpts(manual);
    this.maxIterations = (_f = manual.maxIterations) != null ? _f : 1e4;
    this.includeDtstart = (_g = manual.includeDtstart) != null ? _g : false;
  }
  sanitizeNumericArray(arr, min, max, allowZero = false, sort = false) {
    if (!arr) return void 0;
    const sanitized = arr.filter((n) => Number.isInteger(n) && n >= min && n <= max && (allowZero || n !== 0));
    if (sanitized.length === 0) return void 0;
    return sort ? sanitized.sort((a, b) => a - b) : sanitized;
  }
  sanitizeByDay(byDay) {
    const validDay = /^([+-]?\d{1,2})?(MO|TU|WE|TH|FR|SA|SU)$/;
    const days = (byDay != null ? byDay : []).filter((day) => day && typeof day === "string");
    for (const day of days) {
      const match = day.match(validDay);
      if (!match) {
        throw new Error(`Invalid BYDAY value: ${day}`);
      }
      const ord = match[1];
      if (ord) {
        const ordInt = parseInt(ord, 10);
        if (ordInt === 0) {
          throw new Error(`Invalid BYDAY value: ${day}`);
        }
      }
    }
    return days.length > 0 ? days : void 0;
  }
  sanitizeOpts(opts) {
    var _a;
    opts.byDay = this.sanitizeByDay(opts.byDay);
    if (opts.byMonth) {
      const numeric = opts.byMonth.filter((v) => typeof v === "number");
      const stringy = opts.byMonth.filter((v) => typeof v === "string");
      const sanitizedNum = (_a = this.sanitizeNumericArray(numeric, 1, 12, false, false)) != null ? _a : [];
      const merged = [...sanitizedNum, ...stringy];
      opts.byMonth = merged.length > 0 ? merged : void 0;
    }
    if (opts.rscale && !opts.skip) {
      opts.skip = "OMIT";
    }
    opts.byMonthDay = this.sanitizeNumericArray(opts.byMonthDay, -31, 31, false, false);
    opts.byYearDay = this.sanitizeNumericArray(opts.byYearDay, -366, 366, false, false);
    opts.byWeekNo = this.sanitizeNumericArray(opts.byWeekNo, -53, 53, false, false);
    opts.byHour = this.sanitizeNumericArray(opts.byHour, 0, 23, true, true);
    opts.byMinute = this.sanitizeNumericArray(opts.byMinute, 0, 59, true, true);
    opts.bySecond = this.sanitizeNumericArray(opts.bySecond, 0, 59, true, true);
    if (opts.bySetPos) {
      if (opts.bySetPos.some((p) => p === 0)) {
        throw new Error("bySetPos may not contain 0");
      }
      opts.bySetPos = this.sanitizeNumericArray(opts.bySetPos, -Infinity, Infinity, false, false);
    }
    return opts;
  }
  rawAdvance(zdt) {
    const { freq, interval } = this.opts;
    switch (freq) {
      case "DAILY":
        return zdt.add({ days: interval });
      case "WEEKLY":
        return zdt.add({ weeks: interval });
      case "MONTHLY":
        return zdt.add({ months: interval });
      case "YEARLY":
        return zdt.add({ years: interval });
      case "HOURLY": {
        const originalHour = zdt.hour;
        let next = zdt.add({ hours: interval });
        if (next.hour === originalHour && interval === 1) {
          next = next.add({ hours: interval });
        }
        return next;
      }
      case "MINUTELY":
        return zdt.add({ minutes: interval });
      case "SECONDLY":
        return zdt.add({ seconds: interval });
      default:
        throw new Error(`Unsupported FREQ: ${freq}`);
    }
  }
  /**  Expand one base ZonedDateTime into all BYHOUR × BYMINUTE × BYSECOND
   *  combinations, keeping chronological order. If the options are not
   *  present the original date is returned unchanged.
   */
  expandByTime(base) {
    var _a, _b, _c;
    const hours = (_a = this.opts.byHour) != null ? _a : [base.hour];
    const minutes = (_b = this.opts.byMinute) != null ? _b : [base.minute];
    const seconds = (_c = this.opts.bySecond) != null ? _c : [base.second];
    const out = [];
    for (const h of hours) {
      for (const m of minutes) {
        for (const s of seconds) {
          out.push(base.with({ hour: h, minute: m, second: s }));
        }
      }
    }
    return out.sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
  }
  nextCandidateSameDate(zdt) {
    const { freq, interval = 1, byHour, byMinute, bySecond } = this.opts;
    if (freq === "HOURLY" && byHour && byHour.length === 1) {
      return this.applyTimeOverride(zdt.add({ days: interval }));
    }
    if (freq === "MINUTELY" && byMinute && byMinute.length === 1) {
      return this.applyTimeOverride(zdt.add({ hours: interval }));
    }
    if (bySecond && bySecond.length > 1) {
      const idx = bySecond.indexOf(zdt.second);
      if (idx !== -1 && idx < bySecond.length - 1) {
        return zdt.with({ second: bySecond[idx + 1] });
      }
    }
    if (freq === "MINUTELY" && byHour && byHour.length > 1 && !byMinute) {
      const next = zdt.add({ minutes: interval });
      if (byHour.includes(next.hour)) {
        return next.with({ second: bySecond ? bySecond[0] : zdt.second });
      }
      const nextHour = byHour.find((h) => h > zdt.hour) || byHour[0];
      if (nextHour && nextHour > zdt.hour) {
        return zdt.with({ hour: nextHour, minute: 0, second: bySecond ? bySecond[0] : zdt.second });
      }
      return this.applyTimeOverride(zdt.add({ days: 1 }));
    }
    if (freq === "SECONDLY") {
      let candidate = zdt;
      if (bySecond && bySecond.length > 0) {
        const nextSecondInList = bySecond.find((s) => s > candidate.second);
        if (nextSecondInList !== void 0) {
          return candidate.with({ second: nextSecondInList });
        }
        candidate = candidate.with({ second: bySecond[0] }).add({ minutes: 1 });
      } else {
        candidate = candidate.add({ seconds: interval });
      }
      if (byMinute && byMinute.length > 0) {
        if (!byMinute.includes(candidate.minute) || candidate.minute === zdt.minute && candidate.second < zdt.second) {
          const nextMinuteInList = byMinute.find((m) => m > candidate.minute);
          if (nextMinuteInList !== void 0) {
            return candidate.with({ minute: nextMinuteInList, second: bySecond ? bySecond[0] : 0 });
          }
          candidate = candidate.with({ minute: byMinute[0], second: bySecond ? bySecond[0] : 0 }).add({ hours: 1 });
        }
      }
      if (byHour && byHour.length > 0) {
        if (!byHour.includes(candidate.hour) || candidate.hour === zdt.hour && candidate.minute < zdt.minute) {
          const nextHourInList = byHour.find((h) => h > candidate.hour);
          if (nextHourInList !== void 0) {
            return candidate.with({
              hour: nextHourInList,
              minute: byMinute ? byMinute[0] : 0,
              second: bySecond ? bySecond[0] : 0
            });
          }
          candidate = candidate.with({ hour: byHour[0], minute: byMinute ? byMinute[0] : 0, second: bySecond ? bySecond[0] : 0 }).add({ days: 1 });
        }
      }
      return candidate;
    }
    if (byMinute && byMinute.length > 1) {
      const idx = byMinute.indexOf(zdt.minute);
      if (idx !== -1 && idx < byMinute.length - 1) {
        return zdt.with({
          minute: byMinute[idx + 1],
          second: bySecond ? bySecond[0] : zdt.second
        });
      }
      if (freq === "MINUTELY" && idx === byMinute.length - 1) {
        if (byHour && byHour.length > 0) {
          const currentHourIdx = byHour.indexOf(zdt.hour);
          if (currentHourIdx !== -1 && currentHourIdx < byHour.length - 1) {
            return zdt.with({
              hour: byHour[currentHourIdx + 1],
              minute: byMinute[0],
              second: bySecond ? bySecond[0] : zdt.second
            });
          } else {
            return this.applyTimeOverride(zdt.add({ days: 1 }));
          }
        }
        return zdt.add({ hours: interval }).with({
          minute: byMinute[0],
          second: bySecond ? bySecond[0] : zdt.second
        });
      }
    }
    if (byHour && byHour.length > 1) {
      const idx = byHour.indexOf(zdt.hour);
      if (idx !== -1 && idx < byHour.length - 1) {
        return zdt.with({
          hour: byHour[idx + 1],
          minute: byMinute ? byMinute[0] : zdt.minute,
          second: bySecond ? bySecond[0] : zdt.second
        });
      }
    }
    if (freq === "HOURLY" && byHour && byHour.length > 1) {
      return this.applyTimeOverride(zdt.add({ days: 1 }));
    }
    return this.applyTimeOverride(this.rawAdvance(zdt));
  }
  applyTimeOverride(zdt) {
    const { byHour, byMinute, bySecond } = this.opts;
    let dt = zdt;
    if (byHour) dt = dt.with({ hour: byHour[0] });
    if (byMinute) dt = dt.with({ minute: byMinute[0] });
    if (bySecond) dt = dt.with({ second: bySecond[0] });
    return dt;
  }
  computeFirst() {
    var _a, _b, _c, _d;
    let zdt = this.originalDtstart;
    if (((_a = this.opts.byWeekNo) == null ? void 0 : _a.length) && ["DAILY", "HOURLY", "MINUTELY", "SECONDLY"].includes(this.opts.freq)) {
      let targetWeek = this.opts.byWeekNo[0];
      let targetYear = zdt.year;
      while (targetYear <= zdt.year + 10) {
        const jan1 = zdt.with({ year: targetYear, month: 1, day: 1 });
        const dec31 = zdt.with({ year: targetYear, month: 12, day: 31 });
        let hasTargetWeek = false;
        if (targetWeek > 0) {
          let maxWeek = 52;
          if (jan1.dayOfWeek === 4 || dec31.dayOfWeek === 4) {
            maxWeek = 53;
          }
          hasTargetWeek = targetWeek <= maxWeek;
        } else {
          let maxWeek = 52;
          if (jan1.dayOfWeek === 4 || dec31.dayOfWeek === 4) {
            maxWeek = 53;
          }
          hasTargetWeek = -targetWeek <= maxWeek;
        }
        if (hasTargetWeek) {
          const firstThursday = jan1.add({ days: (4 - jan1.dayOfWeek + 7) % 7 });
          let weekStart;
          if (targetWeek > 0) {
            weekStart = firstThursday.subtract({ days: 3 }).add({ weeks: targetWeek - 1 });
          } else {
            const lastWeek = jan1.dayOfWeek === 4 || dec31.dayOfWeek === 4 ? 53 : 52;
            weekStart = firstThursday.subtract({ days: 3 }).add({ weeks: lastWeek + targetWeek });
          }
          if ((_b = this.opts.byDay) == null ? void 0 : _b.length) {
            const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
            const targetDays = this.opts.byDay.map((tok) => {
              var _a2;
              return (_a2 = tok.match(/(MO|TU|WE|TH|FR|SA|SU)$/)) == null ? void 0 : _a2[1];
            }).filter(Boolean).map((day) => dayMap[day]).filter(Boolean);
            if (targetDays.length) {
              const candidates = targetDays.map((dayOfWeek) => {
                const delta = (dayOfWeek - weekStart.dayOfWeek + 7) % 7;
                return weekStart.add({ days: delta });
              });
              const firstCandidate = candidates.sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b))[0];
              if (firstCandidate && import_polyfill.Temporal.ZonedDateTime.compare(firstCandidate, this.originalDtstart) >= 0) {
                zdt = firstCandidate;
                break;
              }
            }
          } else {
            if (import_polyfill.Temporal.ZonedDateTime.compare(weekStart, this.originalDtstart) >= 0) {
              zdt = weekStart;
              break;
            }
          }
        }
        targetYear++;
      }
    }
    if (((_c = this.opts.byDay) == null ? void 0 : _c.length) && !this.opts.byWeekNo) {
      const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
      const hasOrdinalTokens = this.opts.byDay.some((tok) => /^[+-]?\d/.test(tok));
      if (hasOrdinalTokens && this.opts.byMonth && (this.opts.freq === "MINUTELY" || this.opts.freq === "SECONDLY")) {
        const months = this.opts.byMonth.filter((v) => typeof v === "number").sort((a, b) => a - b);
        let foundFirst = false;
        for (let year = zdt.year; year <= zdt.year + 10 && !foundFirst; year++) {
          for (const month of months) {
            if (year === zdt.year && month < zdt.month) continue;
            const monthSample = zdt.with({ year, month, day: 1 });
            const monthlyOccs = this.generateMonthlyOccurrences(monthSample);
            for (const occ of monthlyOccs) {
              if (import_polyfill.Temporal.ZonedDateTime.compare(occ, zdt) >= 0) {
                if (!occ.toPlainDate().equals(zdt.toPlainDate())) {
                  zdt = this.applyTimeOverride(occ.with({ hour: 0, minute: 0, second: 0 }));
                } else {
                  zdt = occ;
                }
                foundFirst = true;
                break;
              }
            }
            if (foundFirst) break;
          }
        }
      } else {
        let deltas;
        if (["DAILY", "HOURLY", "MINUTELY", "SECONDLY"].includes(this.opts.freq) && this.opts.byDay.every((tok) => /^[A-Z]{2}$/.test(tok))) {
          deltas = this.opts.byDay.map((tok) => (dayMap[tok] - zdt.dayOfWeek + 7) % 7);
        } else {
          deltas = this.opts.byDay.map((tok) => {
            var _a2;
            const wdTok = (_a2 = tok.match(/(MO|TU|WE|TH|FR|SA|SU)$/)) == null ? void 0 : _a2[1];
            return wdTok ? (dayMap[wdTok] - zdt.dayOfWeek + 7) % 7 : null;
          }).filter((d) => d !== null);
        }
        if (deltas.length) {
          zdt = zdt.add({ days: Math.min(...deltas) });
        }
      }
    }
    const { byHour, byMinute, bySecond } = this.opts;
    if (this.opts.freq === "HOURLY" && !byHour && import_polyfill.Temporal.ZonedDateTime.compare(
      zdt.with({ hour: 0, minute: 0, second: 0, microsecond: 0, nanosecond: 0 }),
      this.originalDtstart
    ) > 0) {
      zdt = zdt.with({ hour: 0, minute: 0, second: 0, microsecond: 0, nanosecond: 0 });
    }
    if (this.opts.freq === "MINUTELY" && !byMinute && import_polyfill.Temporal.ZonedDateTime.compare(
      zdt.with({ hour: 0, minute: 0, second: 0, microsecond: 0, nanosecond: 0 }),
      this.originalDtstart
    ) > 0) {
      zdt = zdt.with({ hour: 0, minute: 0, second: 0, microsecond: 0, nanosecond: 0 });
    }
    if (this.opts.freq === "SECONDLY" && ((_d = this.opts.byWeekNo) == null ? void 0 : _d.length) && !bySecond && import_polyfill.Temporal.ZonedDateTime.compare(
      zdt.with({ hour: 0, minute: 0, second: 0, microsecond: 0, nanosecond: 0 }),
      this.originalDtstart
    ) > 0) {
      zdt = zdt.with({ hour: 0, minute: 0, second: 0, microsecond: 0, nanosecond: 0 });
    }
    if (byHour || byMinute || bySecond) {
      const candidates = this.expandByTime(zdt);
      for (const candidate of candidates) {
        if (import_polyfill.Temporal.ZonedDateTime.compare(candidate, this.originalDtstart) >= 0) {
          return candidate;
        }
      }
      zdt = this.applyTimeOverride(this.rawAdvance(zdt));
    }
    return zdt;
  }
  // --- NEW: constraint checks ---
  // 2) Replace your matchesByDay with this:
  matchesByDay(zdt) {
    const { byDay, freq } = this.opts;
    if (!byDay) return true;
    const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
    for (const token of byDay) {
      const m = token.match(/^([+-]?\d{1,2})?(MO|TU|WE|TH|FR|SA|SU)$/);
      if (!m) continue;
      const ord = m[1] ? parseInt(m[1], 10) : 0;
      const weekday = m[2];
      if (!weekday) continue;
      const wd = dayMap[weekday];
      if (freq === "DAILY") {
        if (zdt.dayOfWeek === wd) return true;
        continue;
      }
      if (ord === 0) {
        if (zdt.dayOfWeek === wd) return true;
        continue;
      }
      const month = zdt.month;
      let dt = zdt.with({ day: 1 });
      const candidates = [];
      while (dt.month === month) {
        if (dt.dayOfWeek === wd) candidates.push(dt.day);
        dt = dt.add({ days: 1 });
      }
      const idx = ord > 0 ? ord - 1 : candidates.length + ord;
      if (candidates[idx] === zdt.day) return true;
    }
    return false;
  }
  matchesByMonth(zdt) {
    const { byMonth } = this.opts;
    if (!byMonth) return true;
    const nums = byMonth.filter((v) => typeof v === "number");
    if (nums.length === 0) return true;
    return nums.includes(zdt.month);
  }
  matchesNumericConstraint(value, constraints, maxPositiveValue) {
    return constraints.some((c) => {
      const target = c > 0 ? c : maxPositiveValue + c + 1;
      return value === target;
    });
  }
  matchesByMonthDay(zdt) {
    const { byMonthDay } = this.opts;
    if (!byMonthDay) return true;
    const lastDay = zdt.with({ day: 1 }).add({ months: 1 }).subtract({ days: 1 }).day;
    return this.matchesNumericConstraint(zdt.day, byMonthDay, lastDay);
  }
  matchesByHour(zdt) {
    const { byHour } = this.opts;
    if (!byHour) return true;
    if (byHour.includes(zdt.hour)) {
      return true;
    }
    for (const h of byHour) {
      const intendedTime = zdt.with({ hour: h });
      if (intendedTime.hour === zdt.hour) {
        return true;
      }
    }
    return false;
  }
  matchesByMinute(zdt) {
    const { byMinute } = this.opts;
    if (!byMinute) return true;
    return byMinute.includes(zdt.minute);
  }
  matchesBySecond(zdt) {
    const { bySecond } = this.opts;
    if (!bySecond) return true;
    return bySecond.includes(zdt.second);
  }
  matchesAll(zdt) {
    return this.matchesByMonth(zdt) && this.matchesByWeekNo(zdt) && this.matchesByYearDay(zdt) && this.matchesByMonthDay(zdt) && this.matchesByDay(zdt) && this.matchesByHour(zdt) && this.matchesByMinute(zdt) && this.matchesBySecond(zdt);
  }
  matchesByYearDay(zdt) {
    const { byYearDay } = this.opts;
    if (!byYearDay) return true;
    const dayOfYear = zdt.dayOfYear;
    const last = zdt.with({ month: 12, day: 31 }).dayOfYear;
    return this.matchesNumericConstraint(dayOfYear, byYearDay, last);
  }
  getIsoWeekInfo(zdt) {
    const thursday = zdt.add({ days: 4 - zdt.dayOfWeek });
    const year = thursday.year;
    const jan1 = zdt.with({ year, month: 1, day: 1 });
    const firstThursday = jan1.add({ days: (4 - jan1.dayOfWeek + 7) % 7 });
    const diffDays = thursday.toPlainDate().since(firstThursday.toPlainDate()).days;
    const week = Math.floor(diffDays / 7) + 1;
    return { week, year };
  }
  matchesByWeekNo(zdt) {
    const { byWeekNo } = this.opts;
    if (!byWeekNo) return true;
    const { week, year } = this.getIsoWeekInfo(zdt);
    const jan1 = zdt.with({ year, month: 1, day: 1 });
    const isLeapYear = jan1.inLeapYear;
    const lastWeek = jan1.dayOfWeek === 4 || isLeapYear && jan1.dayOfWeek === 3 ? 53 : 52;
    return byWeekNo.some((wn) => {
      if (wn > 0) {
        return week === wn;
      } else {
        return week === lastWeek + wn + 1;
      }
    });
  }
  options() {
    return this.opts;
  }
  cloneOptions() {
    const _a = this.opts, {
      byHour,
      byMinute,
      bySecond,
      byDay,
      byMonth,
      byMonthDay,
      byYearDay,
      byWeekNo,
      bySetPos,
      rDate,
      exDate
    } = _a, rest = __objRest(_a, [
      "byHour",
      "byMinute",
      "bySecond",
      "byDay",
      "byMonth",
      "byMonthDay",
      "byYearDay",
      "byWeekNo",
      "bySetPos",
      "rDate",
      "exDate"
    ]);
    return __spreadProps(__spreadValues({}, rest), {
      byHour: byHour ? [...byHour] : void 0,
      byMinute: byMinute ? [...byMinute] : void 0,
      bySecond: bySecond ? [...bySecond] : void 0,
      byDay: byDay ? [...byDay] : void 0,
      byMonth: byMonth ? [...byMonth] : void 0,
      byMonthDay: byMonthDay ? [...byMonthDay] : void 0,
      byYearDay: byYearDay ? [...byYearDay] : void 0,
      byWeekNo: byWeekNo ? [...byWeekNo] : void 0,
      bySetPos: bySetPos ? [...bySetPos] : void 0,
      rDate: rDate ? [...rDate] : void 0,
      exDate: exDate ? [...exDate] : void 0
    });
  }
  cloneUpdateOptions(updates) {
    const cloned = {};
    if (Object.prototype.hasOwnProperty.call(updates, "byHour")) {
      cloned.byHour = Array.isArray(updates.byHour) ? [...updates.byHour] : updates.byHour;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "byMinute")) {
      cloned.byMinute = Array.isArray(updates.byMinute) ? [...updates.byMinute] : updates.byMinute;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "bySecond")) {
      cloned.bySecond = Array.isArray(updates.bySecond) ? [...updates.bySecond] : updates.bySecond;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "byDay")) {
      cloned.byDay = Array.isArray(updates.byDay) ? [...updates.byDay] : updates.byDay;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "byMonth")) {
      cloned.byMonth = Array.isArray(updates.byMonth) ? [...updates.byMonth] : updates.byMonth;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "byMonthDay")) {
      cloned.byMonthDay = Array.isArray(updates.byMonthDay) ? [...updates.byMonthDay] : updates.byMonthDay;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "byYearDay")) {
      cloned.byYearDay = Array.isArray(updates.byYearDay) ? [...updates.byYearDay] : updates.byYearDay;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "byWeekNo")) {
      cloned.byWeekNo = Array.isArray(updates.byWeekNo) ? [...updates.byWeekNo] : updates.byWeekNo;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "bySetPos")) {
      cloned.bySetPos = Array.isArray(updates.bySetPos) ? [...updates.bySetPos] : updates.bySetPos;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "rDate")) {
      cloned.rDate = Array.isArray(updates.rDate) ? [...updates.rDate] : updates.rDate;
    }
    if (Object.prototype.hasOwnProperty.call(updates, "exDate")) {
      cloned.exDate = Array.isArray(updates.exDate) ? [...updates.exDate] : updates.exDate;
    }
    return cloned;
  }
  /**
   * Create a new {@link RRuleTemporal} instance with modified options while keeping the current one unchanged.
   *
   * @example
   * ```ts
   * const updated = rule.with({byMonthDay: [3]});
   * ```
   */
  with(updates) {
    var _a, _b;
    const merged = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, this.cloneOptions()), updates), this.cloneUpdateOptions(updates)), {
      tzid: (_a = updates.tzid) != null ? _a : this.opts.tzid,
      dtstart: (_b = updates.dtstart) != null ? _b : this.opts.dtstart
    });
    return new _RRuleTemporal(merged);
  }
  addDtstartIfNeeded(dates, iterator) {
    if (this.includeDtstart && !this.matchesAll(this.originalDtstart)) {
      if (iterator && this.isExcluded(this.originalDtstart)) {
        return true;
      }
      if (iterator && !iterator(this.originalDtstart, dates.length)) {
        return false;
      }
      dates.push(this.originalDtstart);
      if (this.shouldBreakForCountLimit(dates.length)) {
        return false;
      }
    }
    return true;
  }
  processOccurrences(occs, dates, start, iterator, extraFilters) {
    let shouldBreak = false;
    for (const occ of occs) {
      if (import_polyfill.Temporal.ZonedDateTime.compare(occ, start) < 0) continue;
      if (this.opts.until && import_polyfill.Temporal.ZonedDateTime.compare(occ, this.opts.until) > 0) {
        shouldBreak = true;
        break;
      }
      if (extraFilters && !extraFilters(occ)) {
        continue;
      }
      if (iterator && this.isExcluded(occ)) {
        continue;
      }
      if (iterator && !iterator(occ, dates.length)) {
        shouldBreak = true;
        break;
      }
      dates.push(occ);
      if (this.shouldBreakForCountLimit(dates.length)) {
        shouldBreak = true;
        break;
      }
    }
    return { shouldBreak };
  }
  /**
   * Returns all occurrences of the rule.
   * @param iterator - An optional callback iterator function that can be used to filter or modify the occurrences.
   * @returns An array of Temporal.ZonedDateTime objects representing all occurrences of the rule.
   */
  _allMonthlyByDayOrMonthDay(iterator) {
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    let monthCursor = start.with({ day: 1 });
    while (true) {
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      let occs = this.generateMonthlyOccurrences(monthCursor);
      occs = this.applyBySetPos(occs);
      if (monthCursor.month === start.month && occs.some((o) => import_polyfill.Temporal.ZonedDateTime.compare(o, start) < 0) && occs.some((o) => import_polyfill.Temporal.ZonedDateTime.compare(o, start) === 0)) {
        monthCursor = monthCursor.add({ months: this.opts.interval });
        continue;
      }
      const { shouldBreak } = this.processOccurrences(occs, dates, start, iterator);
      if (shouldBreak) {
        break;
      }
      monthCursor = monthCursor.add({ months: this.opts.interval });
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  _allWeekly(iterator) {
    var _a;
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
    const tokens = this.opts.byDay ? [...this.opts.byDay] : this.opts.byMonthDay && this.opts.byMonthDay.length > 0 ? Object.keys(dayMap) : [Object.entries(dayMap).find(([, d]) => d === start.dayOfWeek)[0]];
    const dows = tokens.map((tok) => dayMap[tok.slice(-2)]).filter((d) => d !== void 0).sort((a, b) => a - b);
    const firstWeekDates = dows.map((dw) => {
      const delta = (dw - start.dayOfWeek + 7) % 7;
      return start.add({ days: delta });
    });
    const firstOccurrence = firstWeekDates.reduce((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b) <= 0 ? a : b);
    const wkstDay = (_a = dayMap[this.opts.wkst || "MO"]) != null ? _a : 1;
    const firstOccWeekOffset = (firstOccurrence.dayOfWeek - wkstDay + 7) % 7;
    let weekCursor = firstOccurrence.subtract({ days: firstOccWeekOffset });
    while (true) {
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      let occs = dows.flatMap((dw) => {
        const delta = (dw - wkstDay + 7) % 7;
        const sameDate = weekCursor.add({ days: delta });
        return this.expandByTime(sameDate);
      }).sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
      occs = this.applyBySetPos(occs);
      const { shouldBreak } = this.processOccurrences(
        occs,
        dates,
        start,
        iterator,
        (occ) => this.matchesByMonth(occ) && this.matchesByMonthDay(occ)
      );
      if (shouldBreak) {
        break;
      }
      weekCursor = weekCursor.add({ weeks: this.opts.interval });
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  _allMonthlyByMonth(iterator) {
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    const months = this.opts.byMonth.filter((v) => typeof v === "number").sort((a, b) => a - b);
    let monthOffset = 0;
    let startMonthIndex = months.findIndex((m) => m >= start.month);
    if (startMonthIndex === -1) {
      startMonthIndex = 0;
      monthOffset = 1;
    }
    while (true) {
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      const monthIndex = startMonthIndex + monthOffset;
      const targetMonth = months[monthIndex % months.length];
      const yearsToAdd = Math.floor(monthIndex / months.length);
      const candidate = start.with({
        year: start.year + yearsToAdd,
        month: targetMonth
      });
      if (this.opts.until && import_polyfill.Temporal.ZonedDateTime.compare(candidate, this.opts.until) > 0) {
        break;
      }
      if (import_polyfill.Temporal.ZonedDateTime.compare(candidate, start) >= 0) {
        if (iterator && this.isExcluded(candidate)) {
          continue;
        }
        if (iterator && !iterator(candidate, dates.length)) {
          break;
        }
        dates.push(candidate);
        if (this.shouldBreakForCountLimit(dates.length)) {
          break;
        }
      }
      monthOffset++;
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  _allYearlyByMonth(iterator) {
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    const months = this.opts.byMonth.filter((v) => typeof v === "number").sort((a, b) => a - b);
    let yearOffset = 0;
    while (true) {
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      const year = start.year + yearOffset * this.opts.interval;
      for (const month of months) {
        let occ = start.with({ year, month });
        occ = this.applyTimeOverride(occ);
        if (import_polyfill.Temporal.ZonedDateTime.compare(occ, start) < 0) {
          continue;
        }
        if (this.opts.until && import_polyfill.Temporal.ZonedDateTime.compare(occ, this.opts.until) > 0) {
          return this.applyCountLimitAndMergeRDates(dates, iterator);
        }
        if (iterator && this.isExcluded(occ)) {
          continue;
        }
        if (iterator && !iterator(occ, dates.length)) {
          return this.applyCountLimitAndMergeRDates(dates, iterator);
        }
        dates.push(occ);
        if (this.shouldBreakForCountLimit(dates.length)) {
          return this.applyCountLimitAndMergeRDates(dates, iterator);
        }
      }
      yearOffset++;
    }
  }
  _allYearlyComplex(iterator) {
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    let yearCursor = start.with({ month: 1, day: 1 });
    while (true) {
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      const occs = this.generateYearlyOccurrences(yearCursor);
      const uniqueOccs = [];
      if (occs.length > 0) {
        uniqueOccs.push(occs[0]);
        for (let i = 1; i < occs.length; i++) {
          if (import_polyfill.Temporal.ZonedDateTime.compare(occs[i], occs[i - 1]) !== 0) {
            uniqueOccs.push(occs[i]);
          }
        }
      }
      const { shouldBreak } = this.processOccurrences(uniqueOccs, dates, start, iterator);
      if (shouldBreak) {
        break;
      }
      const interval = this.opts.freq === "WEEKLY" ? 1 : this.opts.interval;
      yearCursor = yearCursor.add({ years: interval });
      if (this.opts.freq === "WEEKLY" && this.opts.until && yearCursor.year > this.opts.until.year) {
        break;
      }
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  _allMinutelySecondlyComplex(iterator) {
    const dates = [];
    let iterationCount = 0;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    let current = this.computeFirst();
    while (true) {
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      if (this.opts.until && import_polyfill.Temporal.ZonedDateTime.compare(current, this.opts.until) > 0) {
        break;
      }
      if (this.matchesAll(current)) {
        if (iterator && this.isExcluded(current)) {
          current = this.nextCandidateSameDate(current);
          continue;
        }
        if (iterator && !iterator(current, dates.length)) {
          break;
        }
        dates.push(current);
        if (this.shouldBreakForCountLimit(dates.length)) {
          break;
        }
        current = this.nextCandidateSameDate(current);
      } else {
        current = this.findNextValidDate(current);
      }
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  _allMonthlyByWeekNo(iterator) {
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    let current = start;
    const weekNos = [...this.opts.byWeekNo].sort((a, b) => a - b);
    const interval = this.opts.interval;
    let monthsAdvanced = 0;
    let lastYearProcessed = -1;
    outer_loop: while (true) {
      if (this.shouldBreakForCountLimit(dates.length)) {
        break;
      }
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      const year = current.year;
      if (year !== lastYearProcessed && current.month >= start.month) {
        lastYearProcessed = year;
        for (const weekNo of weekNos) {
          const occs = this.generateOccurrencesForWeekInYear(year, weekNo);
          for (const occ of occs) {
            if (import_polyfill.Temporal.ZonedDateTime.compare(occ, start) >= 0) {
              if (iterator && this.isExcluded(occ)) {
                continue;
              }
              if (iterator && !iterator(occ, dates.length)) {
                break outer_loop;
              }
              dates.push(occ);
              if (this.shouldBreakForCountLimit(dates.length)) {
                break outer_loop;
              }
            }
          }
        }
      }
      monthsAdvanced += interval;
      current = start.add({ months: monthsAdvanced });
      if (this.opts.until && import_polyfill.Temporal.ZonedDateTime.compare(current, this.opts.until) > 0) {
        break;
      }
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  _allMonthlyByYearDay(iterator) {
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    let year = start.year;
    const yearDays = [...this.opts.byYearDay].sort((a, b) => a - b);
    const interval = this.opts.interval;
    const startMonthAbs = start.year * 12 + start.month;
    outer_loop: while (true) {
      if (this.shouldBreakForCountLimit(dates.length)) {
        break;
      }
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      const yearStart = start.with({ year, month: 1, day: 1 });
      const lastDayOfYear = yearStart.with({ month: 12, day: 31 }).dayOfYear;
      for (const yd of yearDays) {
        const dayNum = yd > 0 ? yd : lastDayOfYear + yd + 1;
        if (dayNum <= 0 || dayNum > lastDayOfYear) continue;
        const baseOcc = yearStart.add({ days: dayNum - 1 });
        for (const occ of this.expandByTime(baseOcc)) {
          if (import_polyfill.Temporal.ZonedDateTime.compare(occ, start) < 0) continue;
          if (dates.some((d) => import_polyfill.Temporal.ZonedDateTime.compare(d, occ) === 0)) continue;
          const occMonthAbs = occ.year * 12 + occ.month;
          if ((occMonthAbs - startMonthAbs) % interval !== 0) {
            continue;
          }
          if (!this.matchesByMonth(occ)) {
            continue;
          }
          if (this.opts.until && import_polyfill.Temporal.ZonedDateTime.compare(occ, this.opts.until) > 0) {
            break outer_loop;
          }
          if (iterator && this.isExcluded(occ)) {
            continue;
          }
          if (iterator && !iterator(occ, dates.length)) {
            break outer_loop;
          }
          dates.push(occ);
          if (this.shouldBreakForCountLimit(dates.length)) {
            break outer_loop;
          }
        }
      }
      year++;
      if (this.opts.until && year > this.opts.until.year + 2) {
        break;
      }
      if (!this.opts.until && this.opts.count) {
        const yearsToScan = Math.ceil(this.opts.count / (this.opts.byYearDay.length || 1)) * interval + 5;
        if (year > start.year + yearsToScan) {
          break;
        }
      }
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  _allDailyMinutelyHourlyWithBySetPos(iterator) {
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    let cursor;
    let duration;
    switch (this.opts.freq) {
      case "MINUTELY":
        cursor = start.with({ second: 0, microsecond: 0, nanosecond: 0 });
        duration = { minutes: this.opts.interval };
        break;
      case "HOURLY":
        cursor = start.with({ minute: 0, second: 0, microsecond: 0, nanosecond: 0 });
        duration = { hours: this.opts.interval };
        break;
      case "DAILY":
        cursor = start.with({ hour: 0, minute: 0, second: 0, microsecond: 0, nanosecond: 0 });
        duration = { days: this.opts.interval };
        break;
      default:
        return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    while (true) {
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      let periodOccs = this.expandByTime(cursor);
      periodOccs = periodOccs.filter((occ) => this.matchesAll(occ));
      periodOccs = this.applyBySetPos(periodOccs);
      const { shouldBreak } = this.processOccurrences(periodOccs, dates, start, iterator);
      if (shouldBreak) {
        break;
      }
      cursor = cursor.add(duration);
      if (this.opts.until && import_polyfill.Temporal.ZonedDateTime.compare(cursor, this.opts.until) > 0) {
        break;
      }
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  _allFallback(iterator) {
    const dates = [];
    let iterationCount = 0;
    let current = this.computeFirst();
    if (this.includeDtstart && import_polyfill.Temporal.ZonedDateTime.compare(current, this.originalDtstart) > 0) {
      if (iterator && this.isExcluded(this.originalDtstart)) {
      } else {
        if (iterator && !iterator(this.originalDtstart, dates.length)) {
          return this.applyCountLimitAndMergeRDates(dates, iterator);
        }
        dates.push(this.originalDtstart);
        if (this.shouldBreakForCountLimit(dates.length)) {
          return this.applyCountLimitAndMergeRDates(dates, iterator);
        }
      }
    }
    while (true) {
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      if (this.opts.until && import_polyfill.Temporal.ZonedDateTime.compare(current, this.opts.until) > 0) {
        break;
      }
      if (this.matchesAll(current)) {
        if (iterator && this.isExcluded(current)) {
        } else {
          if (iterator && !iterator(current, dates.length)) {
            break;
          }
          dates.push(current);
          if (this.shouldBreakForCountLimit(dates.length)) {
            break;
          }
        }
      }
      current = this.nextCandidateSameDate(current);
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  /**
   * Returns all occurrences of the rule.
   * @param iterator - An optional callback iterator function that can be used to filter or modify the occurrences.
   * @returns An array of Temporal.ZonedDateTime objects representing all occurrences of the rule.
   */
  all(iterator) {
    if (this.opts.rscale && ["CHINESE", "HEBREW", "INDIAN"].includes(this.opts.rscale)) {
      if (["YEARLY", "MONTHLY", "WEEKLY"].includes(this.opts.freq) || !!this.opts.byYearDay || !!this.opts.byWeekNo || this.opts.byMonthDay && this.opts.byMonthDay.length > 0) {
        return this._allRscaleNonGregorian(iterator);
      }
    }
    if (this.opts.byWeekNo && this.opts.byYearDay) {
      const yearStart = this.originalDtstart.with({ month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 });
      const yearDays = this.opts.byYearDay.map((yd) => {
        const lastDayOfYear = yearStart.with({ month: 12, day: 31 }).dayOfYear;
        return yd > 0 ? yd : lastDayOfYear + yd + 1;
      });
      let possibleDate = false;
      for (const yd of yearDays) {
        const date = yearStart.add({ days: yd - 1 });
        if (this.matchesByWeekNo(date)) {
          possibleDate = true;
          break;
        }
      }
      if (!possibleDate) {
        return [];
      }
    }
    if (!this.opts.count && !this.opts.until && !iterator) {
      throw new Error("all() requires iterator when no COUNT/UNTIL");
    }
    if (this.opts.freq === "MONTHLY" && (this.opts.byDay || this.opts.byMonthDay) && !this.opts.byWeekNo) {
      return this._allMonthlyByDayOrMonthDay(iterator);
    }
    if (this.opts.freq === "WEEKLY" && !(this.opts.byYearDay && this.opts.byYearDay.length > 0) && !(this.opts.byWeekNo && this.opts.byWeekNo.length > 0)) {
      return this._allWeekly(iterator);
    }
    if (this.opts.freq === "MONTHLY" && this.opts.byMonth && !this.opts.byDay && !this.opts.byMonthDay && !this.opts.byYearDay) {
      return this._allMonthlyByMonth(iterator);
    }
    if (this.opts.freq === "YEARLY" && this.opts.byMonth && !this.opts.byDay && !this.opts.byMonthDay && !this.opts.byYearDay && !this.opts.byWeekNo) {
      return this._allYearlyByMonth(iterator);
    }
    if (this.opts.freq === "YEARLY" && (this.opts.byDay || this.opts.byMonthDay || this.opts.byYearDay || this.opts.byWeekNo) || this.opts.freq === "WEEKLY" && this.opts.byYearDay && this.opts.byYearDay.length > 0 || this.opts.freq === "WEEKLY" && this.opts.byWeekNo && this.opts.byWeekNo.length > 0) {
      return this._allYearlyComplex(iterator);
    }
    if ((this.opts.freq === "MINUTELY" || this.opts.freq === "SECONDLY") && (this.opts.byMonth || this.opts.byWeekNo || this.opts.byYearDay || this.opts.byMonthDay || this.opts.byDay)) {
      return this._allMinutelySecondlyComplex(iterator);
    }
    if (this.opts.freq === "MONTHLY" && this.opts.byWeekNo && this.opts.byWeekNo.length > 0) {
      return this._allMonthlyByWeekNo(iterator);
    }
    if (this.opts.freq === "MONTHLY" && this.opts.byYearDay && this.opts.byYearDay.length > 0 && !this.opts.byDay && !this.opts.byMonthDay) {
      return this._allMonthlyByYearDay(iterator);
    }
    if (this.opts.rscale && this.opts.freq === "MONTHLY" && !this.opts.byDay && !this.opts.byMonthDay && !this.opts.byWeekNo && !this.opts.byYearDay) {
      return this._allMonthlyRscaleSimple(iterator);
    }
    if ((this.opts.freq === "MINUTELY" || this.opts.freq === "HOURLY" || this.opts.freq === "DAILY") && this.opts.bySetPos) {
      return this._allDailyMinutelyHourlyWithBySetPos(iterator);
    }
    return this._allFallback(iterator);
  }
  /**
   * RFC 7529: RSCALE present, simple monthly iteration with SKIP behavior.
   * Handles month-to-month stepping from DTSTART's year/month aiming for DTSTART's day-of-month.
   * Applies SKIP=OMIT (skip invalid months), BACKWARD (clamp to last day), FORWARD (first day of next month).
   */
  _allMonthlyRscaleSimple(iterator) {
    var _a;
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    const interval = (_a = this.opts.interval) != null ? _a : 1;
    const targetDom = start.day;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    let cursor = start.with({ day: 1 });
    while (true) {
      if (++iterationCount > this.maxIterations) {
        throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
      }
      const lastDay = cursor.add({ months: 1 }).subtract({ days: 1 }).day;
      let occ = null;
      if (targetDom <= lastDay) {
        occ = cursor.with({ day: targetDom });
      } else {
        const skip = this.opts.skip || "OMIT";
        if (skip === "BACKWARD") {
          occ = cursor.with({ day: lastDay });
        } else if (skip === "FORWARD") {
          occ = cursor.add({ months: 1 }).with({ day: 1 });
        } else {
          occ = null;
        }
      }
      if (occ) {
        occ = occ.with({ hour: start.hour, minute: start.minute, second: start.second });
        if (!(iterator && this.isExcluded(occ))) {
          if (import_polyfill.Temporal.ZonedDateTime.compare(occ, start) >= 0) {
            if (!iterator || iterator(occ, dates.length)) {
              dates.push(occ);
              if (this.shouldBreakForCountLimit(dates.length)) break;
            } else {
              break;
            }
          }
        }
      }
      cursor = cursor.add({ months: interval });
      if (this.opts.until && import_polyfill.Temporal.ZonedDateTime.compare(cursor, this.opts.until) > 0) {
        break;
      }
    }
    return this.applyCountLimitAndMergeRDates(dates, iterator);
  }
  /**
   * Converts rDate entries to ZonedDateTime and merges with existing dates.
   * @param dates - Array of dates to merge with
   * @returns Merged and deduplicated array of dates
   */
  mergeAndDeduplicateRDates(dates) {
    if (this.opts.rDate) {
      dates.push(...this.opts.rDate);
    }
    dates.sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
    const dedup = [];
    for (const d of dates) {
      if (dedup.length === 0 || import_polyfill.Temporal.ZonedDateTime.compare(d, dedup[dedup.length - 1]) !== 0) {
        dedup.push(d);
      }
    }
    return dedup;
  }
  /**
   * Checks if a date is in the exDate list.
   * @param date - Date to check
   * @returns True if the date is excluded
   */
  isExcluded(date) {
    if (!this.opts.exDate || this.opts.exDate.length === 0) return false;
    return this.opts.exDate.some((exDate) => import_polyfill.Temporal.ZonedDateTime.compare(date, exDate) === 0);
  }
  /**
   * Excludes exDate entries from the given array of dates.
   * @param dates - Array of dates to filter
   * @returns Filtered array with exDate entries removed
   */
  excludeExDates(dates) {
    if (!this.opts.exDate || this.opts.exDate.length === 0) return dates;
    return dates.filter((date) => {
      return !this.isExcluded(date);
    });
  }
  /**
   * Applies count limit and merges rDates with the rule-generated dates.
   * @param dates - Array of dates generated by the rule
   * @param iterator - Optional iterator function
   * @returns Final array of dates after merging and applying count limit
   */
  applyCountLimitAndMergeRDates(dates, iterator) {
    const merged = this.mergeAndDeduplicateRDates(dates);
    const excluded = this.excludeExDates(merged);
    const hasCountLimit = this.opts.count !== void 0;
    if (!hasCountLimit && !iterator) {
      return excluded;
    }
    let emitted = 0;
    const max = hasCountLimit ? this.opts.count : Infinity;
    const finalDates = [];
    for (const d of excluded) {
      if (emitted >= max) break;
      if (iterator && !iterator(d, emitted)) break;
      finalDates.push(d);
      emitted++;
    }
    return finalDates;
  }
  /**
   * Checks if the count limit should break the loop based on rDate presence.
   * @param matchCount - Current number of matches
   * @returns true if the loop should break
   */
  shouldBreakForCountLimit(matchCount) {
    if (this.opts.count === void 0) return false;
    if (!this.opts.rDate) {
      return matchCount >= this.opts.count;
    }
    const rDateCount = this.opts.rDate.length;
    const targetRuleCount = Math.max(this.opts.count - rDateCount, 0);
    const safetyMargin = Math.min(targetRuleCount, 10);
    return matchCount >= targetRuleCount + safetyMargin;
  }
  /**
   * Returns all occurrences of the rule within a specified time window.
   * @param after - The start date or Temporal.ZonedDateTime object.
   * @param before - The end date or Temporal.ZonedDateTime object.
   * @param inc - Optional boolean flag to include the end date in the results.
   * @returns An array of Temporal.ZonedDateTime objects representing all occurrences of the rule within the specified time window.
   */
  between(after, before, inc = false) {
    var _a;
    const startInst = after instanceof Date ? import_polyfill.Temporal.Instant.from(after.toISOString()) : after.toInstant();
    const endInst = before instanceof Date ? import_polyfill.Temporal.Instant.from(before.toISOString()) : before.toInstant();
    const startZdt = import_polyfill.Temporal.Instant.from(startInst).toZonedDateTimeISO(this.tzid);
    const beforeZdt = import_polyfill.Temporal.Instant.from(endInst).toZonedDateTimeISO(this.tzid);
    const tempOpts = __spreadValues({}, this.opts);
    if (!tempOpts.until || import_polyfill.Temporal.ZonedDateTime.compare(beforeZdt, tempOpts.until) < 0) {
      tempOpts.until = beforeZdt;
    }
    if (tempOpts.count === void 0) {
      const interval = (_a = tempOpts.interval) != null ? _a : 1;
      const aligned = startZdt.withPlainTime(this.originalDtstart.toPlainTime());
      let unit;
      switch (tempOpts.freq) {
        case "YEARLY":
          unit = "years";
          break;
        case "MONTHLY":
          unit = "months";
          break;
        case "WEEKLY":
          unit = "weeks";
          break;
        case "DAILY":
          unit = "days";
          break;
        case "HOURLY":
          unit = "hours";
          break;
        case "MINUTELY":
          unit = "minutes";
          break;
        default:
          unit = "seconds";
      }
      const diffDur = this.opts.dtstart.until(aligned, { largestUnit: unit });
      const unitsBetween = diffDur[unit];
      const steps = Math.floor(unitsBetween / interval);
      let toAdd;
      const jump = steps * interval;
      switch (unit) {
        case "years":
          toAdd = { years: jump };
          break;
        case "months":
          toAdd = { months: jump };
          break;
        case "weeks":
          toAdd = { weeks: jump };
          break;
        case "days":
          toAdd = { days: jump };
          break;
        case "hours":
          toAdd = { hours: jump };
          break;
        case "minutes":
          toAdd = { minutes: jump };
          break;
        default:
          toAdd = { seconds: jump };
      }
      let candidate = this.opts.dtstart.add(toAdd);
      if (import_polyfill.Temporal.ZonedDateTime.compare(candidate, this.opts.dtstart) < 0) {
        candidate = this.opts.dtstart;
      }
      tempOpts.dtstart = candidate;
    }
    const tempRule = new _RRuleTemporal(tempOpts);
    const allDates = tempRule.all();
    return allDates.filter((date) => {
      const inst = date.toInstant();
      const afterStart = inc ? import_polyfill.Temporal.Instant.compare(inst, startInst) >= 0 : import_polyfill.Temporal.Instant.compare(inst, startInst) > 0;
      const beforeEnd = inc ? import_polyfill.Temporal.Instant.compare(inst, endInst) <= 0 : import_polyfill.Temporal.Instant.compare(inst, endInst) < 0;
      return afterStart && beforeEnd;
    });
  }
  /**
   * Returns the next occurrence of the rule after a specified date.
   * @param after - The start date or Temporal.ZonedDateTime object.
   * @param inc - Optional boolean flag to include occurrences on the start date.
   * @returns The next occurrence of the rule after the specified date or null if no occurrences are found.
   */
  next(after = /* @__PURE__ */ new Date(), inc = false) {
    const afterInst = after instanceof Date ? import_polyfill.Temporal.Instant.from(after.toISOString()) : after.toInstant();
    let result = null;
    this.all((occ) => {
      const inst = occ.toInstant();
      const ok = inc ? import_polyfill.Temporal.Instant.compare(inst, afterInst) >= 0 : import_polyfill.Temporal.Instant.compare(inst, afterInst) > 0;
      if (ok) {
        if (!result || import_polyfill.Temporal.ZonedDateTime.compare(occ, result) < 0) {
          result = occ;
        }
        return false;
      }
      return true;
    });
    return result;
  }
  /**
   * Returns the previous occurrence of the rule before a specified date.
   * @param before - The end date or Temporal.ZonedDateTime object.
   * @param inc - Optional boolean flag to include occurrences on the end date.
   * @returns The previous occurrence of the rule before the specified date or null if no occurrences are found.
   */
  previous(before = /* @__PURE__ */ new Date(), inc = false) {
    const beforeInst = before instanceof Date ? import_polyfill.Temporal.Instant.from(before.toISOString()) : before.toInstant();
    let prev = null;
    this.all((occ) => {
      const inst = occ.toInstant();
      const beyond = inc ? import_polyfill.Temporal.Instant.compare(inst, beforeInst) > 0 : import_polyfill.Temporal.Instant.compare(inst, beforeInst) >= 0;
      if (beyond) return false;
      prev = occ;
      return true;
    });
    return prev;
  }
  toString() {
    const iso = this.originalDtstart.toString({ smallestUnit: "second" }).replace(/[-:]/g, "");
    const dtLine = `DTSTART;TZID=${this.tzid}:${iso.slice(0, 15)}`;
    const rule = [];
    const {
      freq,
      interval,
      count,
      until,
      byHour,
      byMinute,
      bySecond,
      byDay,
      byMonth,
      byMonthDay,
      bySetPos,
      byWeekNo,
      byYearDay,
      wkst,
      rDate,
      exDate
    } = this.opts;
    if (this.opts.rscale) rule.push(`RSCALE=${this.opts.rscale}`);
    if (this.opts.rscale && this.opts.skip) rule.push(`SKIP=${this.opts.skip}`);
    rule.push(`FREQ=${freq}`);
    if (interval !== 1) rule.push(`INTERVAL=${interval}`);
    if (count !== void 0) rule.push(`COUNT=${count}`);
    if (until) {
      rule.push(`UNTIL=${this.formatIcsDateTime(until)}`);
    }
    if (byHour) rule.push(`BYHOUR=${byHour.join(",")}`);
    if (byMinute) rule.push(`BYMINUTE=${byMinute.join(",")}`);
    if (bySecond) rule.push(`BYSECOND=${bySecond.join(",")}`);
    if (byDay) rule.push(`BYDAY=${byDay.join(",")}`);
    if (byMonth) rule.push(`BYMONTH=${byMonth.join(",")}`);
    if (byMonthDay) rule.push(`BYMONTHDAY=${byMonthDay.join(",")}`);
    if (bySetPos) rule.push(`BYSETPOS=${bySetPos.join(",")}`);
    if (byWeekNo) rule.push(`BYWEEKNO=${byWeekNo.join(",")}`);
    if (byYearDay) rule.push(`BYYEARDAY=${byYearDay.join(",")}`);
    if (wkst) rule.push(`WKST=${wkst}`);
    const lines = [dtLine, `RRULE:${rule.join(";")}`];
    if (rDate) {
      lines.push(`RDATE:${this.joinDates(rDate)}`);
    }
    if (exDate) {
      lines.push(`EXDATE:${this.joinDates(exDate)}`);
    }
    return lines.join("\n");
  }
  formatIcsDateTime(date) {
    return date.toInstant().toString().replace(/[-:]/g, "").slice(0, 15) + "Z";
  }
  joinDates(dates) {
    return dates.map((d) => this.formatIcsDateTime(d));
  }
  /**
   * Given any date in a month, return all the ZonedDateTimes in that month
   * matching your opts.byDay and opts.byMonth (or the single "same day" if no BYDAY).
   */
  generateMonthlyOccurrences(sample) {
    var _a;
    const { byDay, byMonth, byMonthDay } = this.opts;
    if (byMonth && !byMonth.includes(sample.month)) return [];
    const lastDay = sample.with({ day: 1 }).add({ months: 1 }).subtract({ days: 1 }).day;
    let byMonthDayHits = [];
    if (byMonthDay && byMonthDay.length > 0) {
      byMonthDayHits = byMonthDay.map((d) => d > 0 ? d : lastDay + d + 1).filter((d) => d >= 1 && d <= lastDay);
    }
    if (!byDay && byMonthDay && byMonthDay.length > 0) {
      if (byMonthDayHits.length === 0) {
        return [];
      }
      const dates = byMonthDayHits.map((d) => sample.with({ day: d }));
      return dates.flatMap((z) => this.expandByTime(z)).sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
    }
    if (!byDay) {
      return this.expandByTime(sample);
    }
    const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
    const tokens = byDay.map((tok) => {
      const m = tok.match(/^([+-]?\d{1,2})?(MO|TU|WE|TH|FR|SA|SU)$/);
      if (!m) return null;
      return { ord: m[1] ? parseInt(m[1], 10) : 0, wd: dayMap[m[2]] };
    }).filter((x) => x !== null);
    const buckets = {};
    let cursor = sample.with({ day: 1 });
    while (cursor.month === sample.month) {
      const dow = cursor.dayOfWeek;
      (buckets[dow] || (buckets[dow] = [])).push(cursor.day);
      cursor = cursor.add({ days: 1 });
    }
    const byDayHits = [];
    for (const { ord, wd } of tokens) {
      const list2 = (_a = buckets[wd]) != null ? _a : [];
      if (!list2.length) continue;
      if (ord === 0) {
        for (const d of list2) byDayHits.push(d);
      } else {
        const idx = ord > 0 ? ord - 1 : list2.length + ord;
        const dayN = list2[idx];
        if (dayN) byDayHits.push(dayN);
      }
    }
    let finalDays = byDayHits;
    if (byMonthDay && byMonthDay.length > 0) {
      if (byMonthDayHits.length === 0) {
        return [];
      }
      finalDays = finalDays.filter((d) => byMonthDayHits.includes(d));
    }
    const hits = finalDays.map((d) => sample.with({ day: d }));
    return hits.flatMap((z) => this.expandByTime(z)).sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
  }
  /**
   * Given any date in a year, return all ZonedDateTimes in that year matching
   * the BYDAY/BYMONTHDAY/BYMONTH constraints. Months default to DTSTART's month
   * if BYMONTH is not specified.
   */
  generateYearlyOccurrences(sample) {
    const months = this.opts.byMonth ? this.opts.byMonth.filter((v) => typeof v === "number").sort((a, b) => a - b) : this.opts.byMonthDay || this.opts.byDay ? [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] : [this.originalDtstart.month];
    let occs = [];
    const hasOrdinalByDay = this.opts.byDay && this.opts.byDay.some((t) => /^[+-]?\d/.test(t));
    if (hasOrdinalByDay && !this.opts.byMonth) {
      const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
      for (const tok of this.opts.byDay) {
        const m = tok.match(/^([+-]?\d{1,2})(MO|TU|WE|TH|FR|SA|SU)$/);
        if (!m) continue;
        const ord = parseInt(m[1], 10);
        const wd = dayMap[m[2]];
        let dt;
        if (ord > 0) {
          const jan1 = sample.with({ month: 1, day: 1 });
          const delta = (wd - jan1.dayOfWeek + 7) % 7;
          dt = jan1.add({ days: delta + 7 * (ord - 1) });
        } else {
          const dec31 = sample.with({ month: 12, day: 31 });
          const delta = (dec31.dayOfWeek - wd + 7) % 7;
          dt = dec31.subtract({ days: delta + 7 * (-ord - 1) });
        }
        occs.push(...this.expandByTime(dt));
      }
    } else if (!this.opts.byYearDay && !this.opts.byWeekNo) {
      occs = [];
      for (const m of months) {
        const monthSample = sample.with({ month: m, day: 1 });
        const monthOccs = this.generateMonthlyOccurrences(monthSample);
        if (monthOccs.length === 0 && this.opts.rscale && this.opts.byMonthDay && this.opts.byMonthDay.length > 0) {
          const lastDay = monthSample.add({ months: 1 }).subtract({ days: 1 }).day;
          const target = this.opts.byMonthDay[0];
          const absTarget = target > 0 ? target : lastDay + target + 1;
          if (absTarget > lastDay || absTarget <= 0) {
            const skip = this.opts.skip || "OMIT";
            if (skip === "BACKWARD") {
              occs.push(...this.expandByTime(monthSample.with({ day: lastDay })));
            } else if (skip === "FORWARD") {
              const nextMonth = monthSample.add({ months: 1 }).with({ day: 1 });
              occs.push(...this.expandByTime(nextMonth));
            } else {
            }
          }
        } else {
          occs.push(...monthOccs);
        }
      }
    }
    if (this.opts.byYearDay) {
      const last = sample.with({ month: 12, day: 31 }).dayOfYear;
      for (const d of this.opts.byYearDay) {
        const dayNum = d > 0 ? d : last + d + 1;
        if (dayNum <= 0 || dayNum > last) continue;
        const dt = this.opts.freq === "MINUTELY" ? sample.with({ month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }).add({ days: dayNum - 1 }) : sample.with({ month: 1, day: 1 }).add({ days: dayNum - 1 });
        if (!this.opts.byMonth || this.opts.byMonth.includes(dt.month)) {
          occs.push(...this.expandByTime(dt));
        }
      }
    }
    if (this.opts.byWeekNo) {
      const { lastWeek, firstWeekStart, tokens } = this.isoWeekByDay(sample);
      for (const weekNo of this.opts.byWeekNo) {
        if (weekNo > 0 && weekNo > lastWeek || weekNo < 0 && -weekNo > lastWeek) {
          continue;
        }
        const weekIndex = weekNo > 0 ? weekNo - 1 : lastWeek + weekNo;
        const weekStart = firstWeekStart.add({ weeks: weekIndex });
        occs.push(...this.addByDay(tokens, weekStart));
      }
    }
    occs = occs.sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
    occs = this.applyBySetPos(occs);
    return occs;
  }
  addByDay(tokens, weekStart) {
    const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
    const wkst = dayMap[this.opts.wkst || "MO"];
    const entries = [];
    for (const tok of tokens) {
      if (!tok) continue;
      const targetDow = dayMap[tok];
      const inst = weekStart.add({ days: (targetDow - wkst + 7) % 7 });
      if (!this.opts.byMonth || this.opts.byMonth.includes(inst.month)) {
        entries.push(...this.expandByTime(inst));
      }
    }
    return entries;
  }
  /**
   * Helper to find the next valid value from a sorted array
   */
  findNextValidValue(currentValue, validValues, compare) {
    return validValues.find((v) => compare(v, currentValue) > 0) || null;
  }
  /**
   * Efficiently find the next valid date for MINUTELY and SECONDLY frequency by jumping over
   * large gaps when BYXXX constraints don't match.
   */
  findNextValidDate(current) {
    if (this.opts.byWeekNo && this.opts.byYearDay) {
      const yearStart = current.with({ month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 });
      const yearDays = this.opts.byYearDay.map((yd) => {
        const lastDayOfYear = yearStart.with({ month: 12, day: 31 }).dayOfYear;
        return yd > 0 ? yd : lastDayOfYear + yd + 1;
      });
      for (const yd of yearDays) {
        const date = yearStart.add({ days: yd - 1 });
        if (this.matchesByWeekNo(date)) {
          break;
        }
      }
    }
    if (this.opts.byMonth) {
      const numericMonths = this.opts.byMonth.filter((v) => typeof v === "number");
      if (numericMonths.length && !numericMonths.includes(current.month)) {
        const months = [...numericMonths].sort((a, b) => a - b);
        const nextMonth = this.findNextValidValue(current.month, months, (a, b) => a - b);
        if (nextMonth) {
          current = current.with({ month: nextMonth, day: 1, hour: 0, minute: 0, second: 0 });
        } else {
          current = current.add({ years: 1 }).with({ month: months[0], day: 1, hour: 0, minute: 0, second: 0 });
        }
        current = this.applyTimeOverride(current);
        return current;
      }
    }
    if (this.opts.byWeekNo && !this.matchesByWeekNo(current)) {
      current = current.add({ weeks: 1 }).with({ hour: 0, minute: 0, second: 0 });
      current = this.applyTimeOverride(current);
      return current;
    }
    if (this.opts.byYearDay && !this.matchesByYearDay(current)) {
      const yearDays = [...this.opts.byYearDay].sort((a, b) => a - b);
      const currentYearDay = current.dayOfYear;
      const lastDayOfYear = current.with({ month: 12, day: 31 }).dayOfYear;
      let nextYearDay = yearDays.find((d) => {
        const dayNum = d > 0 ? d : lastDayOfYear + d + 1;
        return dayNum > currentYearDay;
      });
      if (nextYearDay) {
        const dayNum = nextYearDay > 0 ? nextYearDay : lastDayOfYear + nextYearDay + 1;
        if (this.opts.freq === "MINUTELY" || this.opts.freq === "SECONDLY") {
          current = current.with({ month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }).add({ days: dayNum - 1 });
        } else {
          current = current.with({ month: 1, day: 1 }).add({ days: dayNum - 1 });
        }
      } else {
        const nextYear = current.add({ years: 1 });
        const nextYearLastDay = nextYear.with({ month: 12, day: 31 }).dayOfYear;
        const firstYearDay = yearDays[0];
        if (firstYearDay !== void 0) {
          const dayNum = firstYearDay > 0 ? firstYearDay : nextYearLastDay + firstYearDay + 1;
          if (this.opts.freq === "MINUTELY" || this.opts.freq === "SECONDLY") {
            current = nextYear.with({ month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }).add({ days: dayNum - 1 });
          } else {
            current = nextYear.with({ month: 1, day: 1 }).add({ days: dayNum - 1 });
          }
        }
      }
      current = this.applyTimeOverride(current);
      return current;
    }
    if (this.opts.byMonthDay && !this.matchesByMonthDay(current)) {
      const monthDays = [...this.opts.byMonthDay].sort((a, b) => a - b);
      const lastDayOfMonth = current.with({ day: 1 }).add({ months: 1 }).subtract({ days: 1 }).day;
      const currentDay = current.day;
      const validDays = monthDays.map((d) => d > 0 ? d : lastDayOfMonth + d + 1).filter((d) => d > 0 && d <= lastDayOfMonth).sort((a, b) => a - b);
      const nextDay = this.findNextValidValue(currentDay, validDays, (a, b) => a - b);
      if (nextDay) {
        current = current.with({ day: nextDay, hour: 0, minute: 0, second: 0 });
      } else {
        const nextMonth = current.add({ months: 1 }).with({ day: 1 });
        const nextMonthLastDay = nextMonth.add({ months: 1 }).subtract({ days: 1 }).day;
        const firstMonthDay = monthDays[0];
        if (firstMonthDay !== void 0) {
          const dayNum = firstMonthDay > 0 ? firstMonthDay : nextMonthLastDay + firstMonthDay + 1;
          current = nextMonth.with({
            day: Math.max(1, Math.min(dayNum, nextMonthLastDay)),
            hour: 0,
            minute: 0,
            second: 0
          });
        } else {
          current = current.add({ months: 1 }).with({ day: 1, hour: 0, minute: 0, second: 0 });
        }
      }
      current = this.applyTimeOverride(current);
      return current;
    }
    if (this.opts.byDay && !this.matchesByDay(current)) {
      const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
      const targetDays = this.opts.byDay.map((tok) => {
        var _a;
        return (_a = tok.match(/(MO|TU|WE|TH|FR|SA|SU)$/)) == null ? void 0 : _a[1];
      }).filter(Boolean).map((day) => dayMap[day]).filter(Boolean);
      const nextDayOfWeek = this.findNextValidValue(current.dayOfWeek, targetDays.sort(), (a, b) => a - b);
      if (nextDayOfWeek) {
        const delta = (nextDayOfWeek - current.dayOfWeek + 7) % 7;
        current = current.add({ days: delta }).with({ hour: 0, minute: 0, second: 0 });
      } else {
        const delta = (targetDays[0] - current.dayOfWeek + 7) % 7;
        current = current.add({ days: delta + 7 }).with({ hour: 0, minute: 0, second: 0 });
      }
      current = this.applyTimeOverride(current);
      return current;
    }
    switch (this.opts.freq) {
      case "SECONDLY":
      case "MINUTELY":
        current = current.add({ days: 1 }).with({ hour: 0, minute: 0, second: 0 });
        break;
      case "HOURLY":
        current = current.add({ days: 1 }).with({ hour: 0, minute: 0, second: 0 });
        break;
      case "DAILY":
      case "WEEKLY":
        current = current.add({ months: 1 }).with({ day: 1, hour: 0, minute: 0, second: 0 });
        break;
      case "MONTHLY":
      case "YEARLY":
        current = current.add({ years: 1 }).with({ month: 1, day: 1, hour: 0, minute: 0, second: 0 });
        break;
    }
    return this.applyTimeOverride(current);
  }
  applyBySetPos(list2) {
    const { bySetPos } = this.opts;
    if (!bySetPos || !bySetPos.length) return list2;
    const sorted = [...list2].sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
    const out = [];
    const len = sorted.length;
    for (const pos of bySetPos) {
      const idx = pos > 0 ? pos - 1 : len + pos;
      if (idx >= 0 && idx < len) out.push(sorted[idx]);
    }
    return out.sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
  }
  isoWeekByDay(sample) {
    var _a;
    const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
    const wkst = dayMap[this.opts.wkst || "MO"];
    const jan1 = sample.with({ month: 1, day: 1 });
    const jan4 = sample.with({ month: 1, day: 4 });
    const delta = (jan4.dayOfWeek - wkst + 7) % 7;
    const firstWeekStart = jan4.subtract({ days: delta });
    const isLeapYear = jan1.inLeapYear;
    const lastWeek = jan1.dayOfWeek === 4 || isLeapYear && jan1.dayOfWeek === 3 ? 53 : 52;
    const tokens = ((_a = this.opts.byDay) == null ? void 0 : _a.length) ? this.opts.byDay.map((tok) => {
      var _a2;
      return (_a2 = tok.match(/(MO|TU|WE|TH|FR|SA|SU)$/)) == null ? void 0 : _a2[1];
    }) : [Object.entries(dayMap).find(([, d]) => d === this.originalDtstart.dayOfWeek)[0]];
    return { lastWeek, firstWeekStart, tokens };
  }
  /**
   * Generate occurrences for a specific week number in a given year
   */
  generateOccurrencesForWeekInYear(year, weekNo) {
    const occs = [];
    const sample = this.originalDtstart.with({ year, month: 1, day: 1 });
    const { lastWeek, firstWeekStart, tokens } = this.isoWeekByDay(sample);
    if (weekNo > 0 && weekNo > lastWeek || weekNo < 0 && -weekNo > lastWeek) {
      return occs;
    }
    const weekIndex = weekNo > 0 ? weekNo - 1 : lastWeek + weekNo;
    const weekStart = firstWeekStart.add({ weeks: weekIndex });
    occs.push(...this.addByDay(tokens, weekStart));
    return occs.sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
  }
  // ===== RSCALE (non-Gregorian) support: Chinese and Hebrew =====
  getRscaleCalendarId() {
    var _a;
    const map = {
      GREGORIAN: "gregory",
      CHINESE: "chinese",
      HEBREW: "hebrew",
      INDIAN: "indian"
    };
    const r = ((_a = this.opts.rscale) == null ? void 0 : _a.toUpperCase()) || "";
    return map[r] || null;
  }
  assertRscaleCalendarSupported(calId) {
    if (calId === "gregory" || calId === "iso8601") return;
    const cached = _RRuleTemporal.rscaleCalendarSupport[calId];
    if (cached === true) return;
    if (cached === false) {
      throw new Error(`RSCALE=${this.opts.rscale} is not supported by the current Temporal/Intl implementation`);
    }
    let supported = true;
    try {
      const probe = import_polyfill.Temporal.ZonedDateTime.from("2000-01-01T00:00:00+00:00[UTC]").withCalendar(calId);
      void probe.year;
      void probe.monthCode;
      void probe.day;
    } catch (e) {
      supported = false;
    }
    _RRuleTemporal.rscaleCalendarSupport[calId] = supported;
    if (!supported) {
      throw new Error(`RSCALE=${this.opts.rscale} is not supported by the current Temporal/Intl implementation`);
    }
  }
  pad2(n) {
    return String(n).padStart(2, "0");
  }
  monthMatchesToken(monthCode, token) {
    if (typeof token === "number") {
      return monthCode === `M${this.pad2(token)}`;
    }
    if (/^\d+L$/i.test(token)) {
      const n = parseInt(token, 10);
      return monthCode === `M${this.pad2(n)}L`;
    }
    return false;
  }
  monthsOfYear(calId, year) {
    const out = [];
    for (let m = 1; m <= 20; m++) {
      try {
        const d = import_polyfill.Temporal.PlainDate.from({ calendar: calId, year, month: m, day: 1 });
        out.push(d);
      } catch (e) {
        break;
      }
    }
    return out;
  }
  startOfYear(calId, year) {
    return import_polyfill.Temporal.PlainDate.from({ calendar: calId, year, month: 1, day: 1 });
  }
  endOfYear(calId, year) {
    return this.startOfYear(calId, year + 1).subtract({ days: 1 });
  }
  rscaleFirstWeekStart(calId, year, wkst) {
    const jan4 = import_polyfill.Temporal.PlainDate.from({ calendar: calId, year, month: 1, day: 4 });
    const delta = (jan4.dayOfWeek - wkst + 7) % 7;
    return jan4.subtract({ days: delta });
  }
  rscaleLastWeekCount(calId, year, wkst) {
    const firstWeekStart = this.rscaleFirstWeekStart(calId, year, wkst);
    const lastDay = this.endOfYear(calId, year);
    const diffDays = lastDay.since(firstWeekStart).days;
    return Math.floor(diffDays / 7) + 1;
  }
  lastDayOfMonth(pd) {
    return pd.with({ day: 1 }).add({ months: 1 }).subtract({ days: 1 }).day;
  }
  buildZdtFromPlainDate(pd) {
    const t = this.originalDtstart;
    const pdt = import_polyfill.Temporal.PlainDateTime.from({
      calendar: pd.calendarId,
      year: pd.year,
      month: pd.month,
      day: pd.day,
      hour: t.hour,
      minute: t.minute,
      second: t.second
    });
    return pdt.toZonedDateTime(this.tzid);
  }
  rscaleMatchesByYearDay(calId, pd) {
    const list2 = this.opts.byYearDay;
    if (!list2 || list2.length === 0) return true;
    const last = this.endOfYear(calId, pd.year).dayOfYear;
    return list2.some((d) => d > 0 ? pd.dayOfYear === d : pd.dayOfYear === last + d + 1);
  }
  rscaleMatchesByWeekNo(calId, pd) {
    const list2 = this.opts.byWeekNo;
    if (!list2 || list2.length === 0) return true;
    const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
    const wkst = dayMap[this.opts.wkst || "MO"];
    const weekStart = pd.subtract({ days: (pd.dayOfWeek - wkst + 7) % 7 });
    const thursday = weekStart.add({ days: (4 - wkst + 7) % 7 });
    const weekYear = thursday.year;
    const firstStart = this.rscaleFirstWeekStart(calId, weekYear, wkst);
    const lastWeek = this.rscaleLastWeekCount(calId, weekYear, wkst);
    const idx = Math.floor(pd.since(firstStart).days / 7) + 1;
    return list2.some((wn) => wn > 0 ? idx === wn : idx === lastWeek + wn + 1);
  }
  rscaleMatchesByMonth(calId, pd) {
    const tokens = this.opts.byMonth;
    if (!tokens || tokens.length === 0) return true;
    return tokens.some((tok) => this.monthMatchesToken(pd.monthCode, tok));
  }
  rscaleMatchesByMonthDay(pd) {
    const list2 = this.opts.byMonthDay;
    if (!list2 || list2.length === 0) return true;
    const last = pd.with({ day: 1 }).add({ months: 1 }).subtract({ days: 1 }).day;
    const value = pd.day;
    return list2.some((d) => d > 0 ? value === d : value === last + d + 1);
  }
  rscaleMatchesByDayBasic(pd) {
    const byDay = this.opts.byDay;
    if (!byDay || byDay.length === 0) return true;
    const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
    const tokens = byDay.map((tok) => {
      var _a;
      return (_a = tok.match(/^(?:[+-]?\d{1,2})?(MO|TU|WE|TH|FR|SA|SU)$/)) == null ? void 0 : _a[1];
    }).filter((x) => !!x);
    if (tokens.length === 0) return true;
    return tokens.some((wd) => dayMap[wd] === pd.dayOfWeek);
  }
  rscaleDateMatches(calId, pd) {
    return this.rscaleMatchesByMonth(calId, pd) && this.rscaleMatchesByYearDay(calId, pd) && this.rscaleMatchesByWeekNo(calId, pd) && this.rscaleMatchesByMonthDay(pd) && this.rscaleMatchesByDayBasic(pd);
  }
  applySkipForDay(calId, year, monthStart, targetDay) {
    const last = this.lastDayOfMonth(monthStart);
    const skip = this.opts.skip || "OMIT";
    if (targetDay >= 1 && targetDay <= last) {
      return monthStart.with({ day: targetDay });
    }
    if (skip === "BACKWARD") {
      return monthStart.with({ day: last });
    }
    if (skip === "FORWARD") {
      const nextMonthStart = monthStart.add({ months: 1 });
      return nextMonthStart.with({ day: 1 });
    }
    return null;
  }
  generateMonthlyOccurrencesRscale(calId, year, monthStart) {
    const occs = [];
    const byMonthDay = this.opts.byMonthDay;
    const byDay = this.opts.byDay;
    if (!byDay && !byMonthDay) {
      const targetDay = this.originalDtstart.withCalendar(calId).day;
      const pd = this.applySkipForDay(calId, year, monthStart, targetDay);
      if (pd) occs.push(this.buildZdtFromPlainDate(pd));
      return occs;
    }
    const addZ = (pd) => {
      occs.push(this.buildZdtFromPlainDate(pd));
    };
    const last = this.lastDayOfMonth(monthStart);
    const resolveDay = (d) => d > 0 ? d : last + d + 1;
    if (byMonthDay && byMonthDay.length > 0) {
      for (const raw of byMonthDay) {
        const dayNum = resolveDay(raw);
        const pd = this.applySkipForDay(calId, year, monthStart, dayNum);
        if (pd) addZ(pd);
      }
    }
    if (byDay && byDay.length > 0) {
      const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
      const buckets = {};
      let cur = monthStart;
      while (cur.month === monthStart.month && cur.year === monthStart.year) {
        const wd = cur.dayOfWeek;
        (buckets[wd] || (buckets[wd] = [])).push(cur);
        cur = cur.add({ days: 1 });
      }
      for (const tok of byDay) {
        const m = tok.match(/^([+-]?\d{1,2})?(MO|TU|WE|TH|FR|SA|SU)$/);
        if (!m) continue;
        const ord = m[1] ? parseInt(m[1], 10) : 0;
        const wd = dayMap[m[2]];
        const list2 = buckets[wd] || [];
        if (list2.length === 0) continue;
        if (ord === 0) {
          for (const pd of list2) addZ(pd);
        } else {
          const idx = ord > 0 ? ord - 1 : list2.length + ord;
          const pd = list2[idx];
          if (pd) addZ(pd);
        }
      }
    }
    return this.applyBySetPos(occs).sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
  }
  _allRscaleNonGregorian(iterator) {
    var _a, _b, _c, _d, _e, _f, _g;
    const calId = this.getRscaleCalendarId();
    if (!calId) return this._allFallback(iterator);
    this.assertRscaleCalendarSupported(calId);
    const dates = [];
    let iterationCount = 0;
    const start = this.originalDtstart;
    const seed = start.withCalendar(calId);
    const interval = (_a = this.opts.interval) != null ? _a : 1;
    if (!this.addDtstartIfNeeded(dates, iterator)) {
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    if (this.opts.freq === "YEARLY") {
      let yearOffset = 0;
      while (true) {
        if (++iterationCount > this.maxIterations) {
          throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
        }
        const tgtYear = seed.year + yearOffset * interval;
        let occs = [];
        const monthsTokens = this.opts.byMonth;
        const months = this.monthsOfYear(calId, tgtYear);
        const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
        const wkst = dayMap[this.opts.wkst || "MO"];
        if (this.opts.byWeekNo && this.opts.byWeekNo.length > 0) {
          const firstStart = this.rscaleFirstWeekStart(calId, tgtYear, wkst);
          const lastWeek = this.rscaleLastWeekCount(calId, tgtYear, wkst);
          const tokens = ((_b = this.opts.byDay) == null ? void 0 : _b.length) ? this.opts.byDay.map((tok) => {
            var _a2;
            return (_a2 = tok.match(/(MO|TU|WE|TH|FR|SA|SU)$/)) == null ? void 0 : _a2[1];
          }) : [Object.entries(dayMap).find(([, d]) => d === this.originalDtstart.dayOfWeek)[0]];
          for (const wn of this.opts.byWeekNo) {
            let idx = wn > 0 ? wn - 1 : lastWeek + wn;
            if (idx < 0 || idx >= lastWeek) continue;
            const weekStart = firstStart.add({ weeks: idx });
            for (const tok of tokens) {
              const targetDow = dayMap[tok];
              const pd = weekStart.add({ days: (targetDow - wkst + 7) % 7 });
              if (monthsTokens && monthsTokens.length > 0) {
                if (!monthsTokens.some((t) => this.monthMatchesToken(pd.monthCode, t))) continue;
              }
              if (this.opts.byYearDay && this.opts.byYearDay.length > 0) {
                const lastDay = this.endOfYear(calId, tgtYear).dayOfYear;
                const matches = this.opts.byYearDay.some((d) => {
                  const target = d > 0 ? d : lastDay + d + 1;
                  return pd.dayOfYear === target;
                });
                if (!matches) continue;
              }
              occs.push(this.buildZdtFromPlainDate(pd));
            }
          }
        } else if (this.opts.byYearDay && this.opts.byYearDay.length > 0) {
          const startOfYear = this.startOfYear(calId, tgtYear);
          const lastDay = this.endOfYear(calId, tgtYear).dayOfYear;
          for (const d of this.opts.byYearDay) {
            const target = d > 0 ? d : lastDay + d + 1;
            if (target < 1 || target > lastDay) continue;
            let pd = startOfYear.add({ days: target - 1 });
            if (monthsTokens && monthsTokens.length > 0) {
              if (!monthsTokens.some((t) => this.monthMatchesToken(pd.monthCode, t))) continue;
            }
            occs.push(this.buildZdtFromPlainDate(pd));
          }
        } else if (!monthsTokens || monthsTokens.length === 0) {
          try {
            const pd = import_polyfill.Temporal.PlainDate.from({
              calendar: calId,
              year: tgtYear,
              monthCode: seed.monthCode,
              day: seed.day
            });
            occs.push(this.buildZdtFromPlainDate(pd));
          } catch (e) {
            const skip = this.opts.skip || "OMIT";
            if (skip === "FORWARD" || skip === "BACKWARD") {
              const mapped = seed.with({ year: tgtYear });
              const adjusted = skip === "BACKWARD" ? mapped.subtract({ days: 1 }) : mapped;
              occs.push(adjusted.withCalendar("iso8601"));
            }
          }
        } else {
          const monthStarts = months.filter((m) => monthsTokens.some((tok) => this.monthMatchesToken(m.monthCode, tok)));
          for (const ms of monthStarts) {
            occs.push(...this.generateMonthlyOccurrencesRscale(calId, tgtYear, ms));
          }
        }
        if (occs.length > 0) {
          const expanded = occs.flatMap((z) => this.expandByTime(z));
          const sorted = expanded.sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
          const { shouldBreak } = this.processOccurrences(sorted, dates, start, iterator);
          if (shouldBreak) break;
        }
        yearOffset++;
        if (this.opts.until && tgtYear > this.opts.until.withCalendar(calId).year) break;
      }
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    if (this.opts.freq === "WEEKLY") {
      const dayMap = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 7 };
      const wkst = dayMap[this.opts.wkst || "MO"];
      const tokens = ((_c = this.opts.byDay) == null ? void 0 : _c.length) ? this.opts.byDay.map((tok) => {
        var _a2;
        return (_a2 = tok.match(/(MO|TU|WE|TH|FR|SA|SU)$/)) == null ? void 0 : _a2[1];
      }) : [Object.entries(dayMap).find(([, d]) => d === this.originalDtstart.dayOfWeek)[0]];
      let weekStart = seed.toPlainDate().subtract({ days: (seed.dayOfWeek - wkst + 7) % 7 });
      while (true) {
        if (++iterationCount > this.maxIterations) {
          throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
        }
        const occs = [];
        for (const tok of tokens) {
          const targetDow = dayMap[tok];
          const pd = weekStart.add({ days: (targetDow - wkst + 7) % 7 });
          if (import_polyfill.Temporal.ZonedDateTime.compare(this.buildZdtFromPlainDate(pd), this.originalDtstart) < 0) {
            continue;
          }
          if (this.opts.byWeekNo && this.opts.byWeekNo.length > 0) {
            const thursday = weekStart.add({ days: (4 - wkst + 7) % 7 });
            const weekYear = thursday.year;
            const firstStart = this.rscaleFirstWeekStart(calId, weekYear, wkst);
            const lastWeek = this.rscaleLastWeekCount(calId, weekYear, wkst);
            const idx = Math.floor(pd.since(firstStart).days / 7) + 1;
            const match = this.opts.byWeekNo.some((wn) => wn > 0 ? idx === wn : idx === lastWeek + wn + 1);
            if (!match) continue;
          }
          if (this.opts.byYearDay && this.opts.byYearDay.length > 0) {
            const last = this.endOfYear(calId, pd.year).dayOfYear;
            const match = this.opts.byYearDay.some((d) => d > 0 ? pd.dayOfYear === d : pd.dayOfYear === last + d + 1);
            if (!match) continue;
          }
          const monthsTokens = this.opts.byMonth;
          if (monthsTokens && monthsTokens.length > 0) {
            if (!monthsTokens.some((t) => this.monthMatchesToken(pd.monthCode, t))) continue;
          }
          occs.push(this.buildZdtFromPlainDate(pd));
        }
        if (occs.length) {
          const expanded = occs.flatMap((z) => this.expandByTime(z));
          const sorted = expanded.sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
          const { shouldBreak } = this.processOccurrences(sorted, dates, start, iterator);
          if (shouldBreak) return this.applyCountLimitAndMergeRDates(dates, iterator);
        }
        weekStart = weekStart.add({ weeks: (_d = this.opts.interval) != null ? _d : 1 });
        if (this.opts.until) {
          const z = this.buildZdtFromPlainDate(weekStart.add({ days: 6 }));
          if (import_polyfill.Temporal.ZonedDateTime.compare(z, this.opts.until) > 0) break;
        }
      }
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    if (this.opts.freq === "MONTHLY") {
      let cursor = seed.toPlainDate().with({ day: 1 });
      while (true) {
        if (++iterationCount > this.maxIterations) {
          throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
        }
        const year = cursor.year;
        const monthStart = cursor;
        let proceed = true;
        const monthsTokens = this.opts.byMonth;
        if (monthsTokens && monthsTokens.length > 0) {
          proceed = monthsTokens.some((tok) => this.monthMatchesToken(monthStart.monthCode, tok));
        }
        if (proceed) {
          const occs = this.generateMonthlyOccurrencesRscale(calId, year, monthStart);
          const expanded = occs.flatMap((z) => this.expandByTime(z));
          const sorted = expanded.sort((a, b) => import_polyfill.Temporal.ZonedDateTime.compare(a, b));
          const { shouldBreak } = this.processOccurrences(sorted, dates, start, iterator);
          if (shouldBreak) break;
        }
        cursor = cursor.add({ months: (_e = this.opts.interval) != null ? _e : 1 });
        if (this.opts.until) {
          const z = this.buildZdtFromPlainDate(cursor);
          if (import_polyfill.Temporal.ZonedDateTime.compare(z, this.opts.until) > 0) break;
        }
      }
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    if (this.opts.freq === "DAILY") {
      let pd = seed.toPlainDate();
      while (true) {
        if (++iterationCount > this.maxIterations) {
          throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
        }
        if (this.rscaleDateMatches(calId, pd)) {
          const base = this.buildZdtFromPlainDate(pd);
          let occs = this.expandByTime(base);
          occs = this.applyBySetPos(occs);
          const { shouldBreak } = this.processOccurrences(occs, dates, start, iterator);
          if (shouldBreak) break;
        }
        pd = pd.add({ days: (_f = this.opts.interval) != null ? _f : 1 });
        if (this.opts.until) {
          const z = this.buildZdtFromPlainDate(pd);
          if (import_polyfill.Temporal.ZonedDateTime.compare(z, this.opts.until) > 0) break;
        }
      }
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    if (this.opts.freq === "HOURLY" || this.opts.freq === "MINUTELY") {
      const unit = this.opts.freq === "HOURLY" ? "hour" : "minute";
      const unitMs = this.opts.freq === "HOURLY" ? 36e5 : 6e4;
      const interval2 = (_g = this.opts.interval) != null ? _g : 1;
      let pd = seed.toPlainDate();
      const startInstantMs = this.originalDtstart.toInstant().epochMilliseconds;
      while (true) {
        if (++iterationCount > this.maxIterations) {
          throw new Error(`Maximum iterations (${this.maxIterations}) exceeded in all()`);
        }
        if (this.rscaleDateMatches(calId, pd)) {
          const base = this.buildZdtFromPlainDate(pd);
          let occs = this.expandByTime(base);
          occs = occs.filter((occ) => {
            const delta = occ.toInstant().epochMilliseconds - startInstantMs;
            const steps = Math.floor(delta / unitMs);
            return steps % interval2 === 0;
          });
          const { shouldBreak } = this.processOccurrences(occs, dates, start, iterator);
          if (shouldBreak) break;
        }
        pd = pd.add({ days: 1 });
        if (this.opts.until) {
          const z = this.buildZdtFromPlainDate(pd);
          if (import_polyfill.Temporal.ZonedDateTime.compare(z, this.opts.until) > 0) break;
        }
      }
      return this.applyCountLimitAndMergeRDates(dates, iterator);
    }
    return this._allFallback(iterator);
  }
};
_RRuleTemporal.rscaleCalendarSupport = {};
var RRuleTemporal = _RRuleTemporal;

// src/totext.ts
var en = {
  weekdayNames: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  units: {
    year: { singular: "year", plural: "years" },
    month: { singular: "month", plural: "months" },
    week: { singular: "week", plural: "weeks" },
    day: { singular: "day", plural: "days" },
    hour: { singular: "hour", plural: "hours" },
    minute: { singular: "minute", plural: "minutes" },
    second: { singular: "second", plural: "seconds" }
  },
  words: {
    every: "every",
    weekday: "weekday",
    on: "on",
    in: "in",
    on_the: "on the",
    day_of_month: "day of the month",
    day_of_year: "day of the year",
    in_week: "in week",
    at: "at",
    at_minute: "at minute",
    at_second: "at second",
    until: "until",
    for: "for",
    time: "time",
    times: "times",
    instance: "instance",
    week_starts_on: "week starts on",
    with: "with",
    additional_date: "additional date",
    additional_dates: "additional dates",
    excluding: "excluding",
    date: "date",
    dates: "dates",
    and: "and",
    last: "last"
  },
  ordinal: (n) => {
    const abs = Math.abs(n);
    const suffix = abs % 10 === 1 && abs % 100 !== 11 ? "st" : abs % 10 === 2 && abs % 100 !== 12 ? "nd" : abs % 10 === 3 && abs % 100 !== 13 ? "rd" : "th";
    return n < 0 ? `last` : `${abs}${suffix}`;
  }
};
var de = {
  weekdayNames: ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag", "Sonntag"],
  monthNames: [
    "Januar",
    "Februar",
    "M\xE4rz",
    "April",
    "Mai",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember"
  ],
  units: {
    year: { singular: "Jahr", plural: "Jahre" },
    month: { singular: "Monat", plural: "Monate" },
    week: { singular: "Woche", plural: "Wochen" },
    day: { singular: "Tag", plural: "Tage" },
    hour: { singular: "Stunde", plural: "Stunden" },
    minute: { singular: "Minute", plural: "Minuten" },
    second: { singular: "Sekunde", plural: "Sekunden" }
  },
  words: {
    every: "jede/n/s",
    weekday: "Werktag",
    on: "am",
    in: "im",
    on_the: "am",
    day_of_month: "Tag des Monats",
    day_of_year: "Tag des Jahres",
    in_week: "in Kalenderwoche",
    at: "um",
    at_minute: "in Minute",
    at_second: "in Sekunde",
    until: "bis",
    for: "f\xFCr",
    time: "Mal",
    times: "Mal",
    instance: "Vorkommen",
    week_starts_on: "Woche beginnt am",
    with: "mit",
    additional_date: "zus\xE4tzlichem Datum",
    additional_dates: "zus\xE4tzlichen Daten",
    excluding: "ohne",
    date: "Datum",
    dates: "Daten",
    and: "und",
    last: "letzter"
  },
  ordinal: (n) => {
    if (n < 0) return "letzten";
    return `${Math.abs(n)}.`;
  }
};
var es = {
  weekdayNames: ["lunes", "martes", "mi\xE9rcoles", "jueves", "viernes", "s\xE1bado", "domingo"],
  monthNames: [
    "enero",
    "febrero",
    "marzo",
    "abril",
    "mayo",
    "junio",
    "julio",
    "agosto",
    "septiembre",
    "octubre",
    "noviembre",
    "diciembre"
  ],
  units: {
    year: { singular: "a\xF1o", plural: "a\xF1os" },
    month: { singular: "mes", plural: "meses" },
    week: { singular: "semana", plural: "semanas" },
    day: { singular: "d\xEDa", plural: "d\xEDas" },
    hour: { singular: "hora", plural: "horas" },
    minute: { singular: "minuto", plural: "minutos" },
    second: { singular: "segundo", plural: "segundos" }
  },
  words: {
    every: "cada",
    weekday: "d\xEDa de la semana",
    on: "en",
    in: "en",
    on_the: "el",
    day_of_month: "d\xEDa del mes",
    day_of_year: "d\xEDa del a\xF1o",
    in_week: "en la semana",
    at: "a las",
    at_minute: "en el minuto",
    at_second: "en el segundo",
    until: "hasta",
    for: "durante",
    time: "vez",
    times: "veces",
    instance: "ocasi\xF3n",
    week_starts_on: "la semana comienza el",
    with: "con",
    additional_date: "fecha adicional",
    additional_dates: "fechas adicionales",
    excluding: "excluyendo",
    date: "fecha",
    dates: "fechas",
    and: "y",
    last: "\xFAltimo"
  },
  ordinal: (n) => n < 0 ? "\xFAltimo" : `${Math.abs(n)}\xBA`
};
var hi = {
  weekdayNames: ["\u0938\u094B\u092E\u0935\u093E\u0930", "\u092E\u0902\u0917\u0932\u0935\u093E\u0930", "\u092C\u0941\u0927\u0935\u093E\u0930", "\u0917\u0941\u0930\u0941\u0935\u093E\u0930", "\u0936\u0941\u0915\u094D\u0930\u0935\u093E\u0930", "\u0936\u0928\u093F\u0935\u093E\u0930", "\u0930\u0935\u093F\u0935\u093E\u0930"],
  monthNames: [
    "\u091C\u0928\u0935\u0930\u0940",
    "\u092B\u0930\u0935\u0930\u0940",
    "\u092E\u093E\u0930\u094D\u091A",
    "\u0905\u092A\u094D\u0930\u0948\u0932",
    "\u092E\u0908",
    "\u091C\u0942\u0928",
    "\u091C\u0941\u0932\u093E\u0908",
    "\u0905\u0917\u0938\u094D\u0924",
    "\u0938\u093F\u0924\u0902\u092C\u0930",
    "\u0905\u0915\u094D\u091F\u0942\u092C\u0930",
    "\u0928\u0935\u0902\u092C\u0930",
    "\u0926\u093F\u0938\u0902\u092C\u0930"
  ],
  units: {
    year: { singular: "\u0938\u093E\u0932", plural: "\u0938\u093E\u0932" },
    month: { singular: "\u092E\u0939\u0940\u0928\u093E", plural: "\u092E\u0939\u0940\u0928\u0947" },
    week: { singular: "\u0938\u092A\u094D\u0924\u093E\u0939", plural: "\u0938\u092A\u094D\u0924\u093E\u0939" },
    day: { singular: "\u0926\u093F\u0928", plural: "\u0926\u093F\u0928" },
    hour: { singular: "\u0918\u0902\u091F\u093E", plural: "\u0918\u0902\u091F\u0947" },
    minute: { singular: "\u092E\u093F\u0928\u091F", plural: "\u092E\u093F\u0928\u091F" },
    second: { singular: "\u0938\u0947\u0915\u0902\u0921", plural: "\u0938\u0947\u0915\u0902\u0921" }
  },
  words: {
    every: "\u0939\u0930",
    weekday: "\u0938\u092A\u094D\u0924\u093E\u0939 \u0915\u093E \u0926\u093F\u0928",
    on: "\u0915\u094B",
    in: "\u092E\u0947\u0902",
    on_the: "\u0915\u094B",
    day_of_month: "\u092E\u0939\u0940\u0928\u0947 \u0915\u093E \u0926\u093F\u0928",
    day_of_year: "\u0938\u093E\u0932 \u0915\u093E \u0926\u093F\u0928",
    in_week: "\u0938\u092A\u094D\u0924\u093E\u0939",
    at: "\u092A\u0930",
    at_minute: "\u092E\u093F\u0928\u091F \u092A\u0930",
    at_second: "\u0938\u0947\u0915\u0902\u0921 \u092A\u0930",
    until: "\u0924\u0915",
    for: "\u0915\u0947 \u0932\u093F\u090F",
    time: "\u092C\u093E\u0930",
    times: "\u092C\u093E\u0930",
    instance: "\u092C\u093E\u0930",
    week_starts_on: "\u0938\u092A\u094D\u0924\u093E\u0939 \u0936\u0941\u0930\u0942 \u0939\u094B\u0924\u093E \u0939\u0948",
    with: "\u0938\u093E\u0925",
    additional_date: "\u0905\u0924\u093F\u0930\u093F\u0915\u094D\u0924 \u0924\u093E\u0930\u0940\u0916",
    additional_dates: "\u0905\u0924\u093F\u0930\u093F\u0915\u094D\u0924 \u0924\u093E\u0930\u0940\u0916\u0947\u0902",
    excluding: "\u0915\u094B \u091B\u094B\u0921\u093C\u0915\u0930",
    date: "\u0924\u093E\u0930\u0940\u0916",
    dates: "\u0924\u093E\u0930\u0940\u0916\u0947\u0902",
    and: "\u0914\u0930",
    last: "\u0906\u0916\u093F\u0930\u0940"
  },
  ordinal: (n) => n < 0 ? "\u0906\u0916\u093F\u0930\u0940" : `${Math.abs(n)}\u0935\u093E\u0902`
};
var yue = {
  weekdayNames: ["\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D", "\u661F\u671F\u65E5"],
  monthNames: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"],
  units: {
    year: { singular: "\u5E74", plural: "\u5E74" },
    month: { singular: "\u6708", plural: "\u6708" },
    week: { singular: "\u9031", plural: "\u9031" },
    day: { singular: "\u65E5", plural: "\u65E5" },
    hour: { singular: "\u5C0F\u6642", plural: "\u5C0F\u6642" },
    minute: { singular: "\u5206\u9418", plural: "\u5206\u9418" },
    second: { singular: "\u79D2", plural: "\u79D2" }
  },
  words: {
    every: "\u6BCF",
    weekday: "\u5E73\u65E5",
    on: "\u5728",
    in: "\u65BC",
    on_the: "\u5728",
    day_of_month: "\u6708\u7684\u65E5\u5B50",
    day_of_year: "\u5E74\u7684\u65E5\u5B50",
    in_week: "\u7B2C",
    at: "\u5728",
    at_minute: "\u5728\u7B2C",
    at_second: "\u5728\u7B2C",
    until: "\u76F4\u5230",
    for: "\u5171",
    time: "\u6B21",
    times: "\u6B21",
    instance: "\u6B21",
    week_starts_on: "\u661F\u671F\u958B\u59CB\u65BC",
    with: "\u5E36\u6709",
    additional_date: "\u984D\u5916\u65E5\u671F",
    additional_dates: "\u984D\u5916\u65E5\u671F",
    excluding: "\u6392\u9664",
    date: "\u65E5\u671F",
    dates: "\u65E5\u671F",
    and: "\u548C",
    last: "\u6700\u5F8C"
  },
  ordinal: (n) => n < 0 ? "\u6700\u5F8C" : `\u7B2C${Math.abs(n)}`
};
var ar = {
  weekdayNames: ["\u0627\u0644\u0627\u062B\u0646\u064A\u0646", "\u0627\u0644\u062B\u0644\u0627\u062B\u0627\u0621", "\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621", "\u0627\u0644\u062E\u0645\u064A\u0633", "\u0627\u0644\u062C\u0645\u0639\u0629", "\u0627\u0644\u0633\u0628\u062A", "\u0627\u0644\u0623\u062D\u062F"],
  monthNames: [
    "\u064A\u0646\u0627\u064A\u0631",
    "\u0641\u0628\u0631\u0627\u064A\u0631",
    "\u0645\u0627\u0631\u0633",
    "\u0623\u0628\u0631\u064A\u0644",
    "\u0645\u0627\u064A\u0648",
    "\u064A\u0648\u0646\u064A\u0648",
    "\u064A\u0648\u0644\u064A\u0648",
    "\u0623\u063A\u0633\u0637\u0633",
    "\u0633\u0628\u062A\u0645\u0628\u0631",
    "\u0623\u0643\u062A\u0648\u0628\u0631",
    "\u0646\u0648\u0641\u0645\u0628\u0631",
    "\u062F\u064A\u0633\u0645\u0628\u0631"
  ],
  units: {
    year: { singular: "\u0633\u0646\u0629", plural: "\u0633\u0646\u0648\u0627\u062A" },
    month: { singular: "\u0634\u0647\u0631", plural: "\u0623\u0634\u0647\u0631" },
    week: { singular: "\u0623\u0633\u0628\u0648\u0639", plural: "\u0623\u0633\u0627\u0628\u064A\u0639" },
    day: { singular: "\u064A\u0648\u0645", plural: "\u0623\u064A\u0627\u0645" },
    hour: { singular: "\u0633\u0627\u0639\u0629", plural: "\u0633\u0627\u0639\u0627\u062A" },
    minute: { singular: "\u062F\u0642\u064A\u0642\u0629", plural: "\u062F\u0642\u0627\u0626\u0642" },
    second: { singular: "\u062B\u0627\u0646\u064A\u0629", plural: "\u062B\u0648\u0627\u0646\u064A" }
  },
  words: {
    every: "\u0643\u0644",
    weekday: "\u064A\u0648\u0645 \u0645\u0646 \u0623\u064A\u0627\u0645 \u0627\u0644\u0623\u0633\u0628\u0648\u0639",
    on: "\u0641\u064A",
    in: "\u0641\u064A",
    on_the: "\u0641\u064A \u0627\u0644\u0640",
    day_of_month: "\u064A\u0648\u0645 \u0645\u0646 \u0627\u0644\u0634\u0647\u0631",
    day_of_year: "\u064A\u0648\u0645 \u0645\u0646 \u0627\u0644\u0633\u0646\u0629",
    in_week: "\u0641\u064A \u0627\u0644\u0623\u0633\u0628\u0648\u0639",
    at: "\u0639\u0646\u062F",
    at_minute: "\u0641\u064A \u0627\u0644\u062F\u0642\u064A\u0642\u0629",
    at_second: "\u0641\u064A \u0627\u0644\u062B\u0627\u0646\u064A\u0629",
    until: "\u062D\u062A\u0649",
    for: "\u0644\u0645\u062F\u0629",
    time: "\u0645\u0631\u0629",
    times: "\u0645\u0631\u0627\u062A",
    instance: "\u0645\u0631\u0629",
    week_starts_on: "\u064A\u0628\u062F\u0623 \u0627\u0644\u0623\u0633\u0628\u0648\u0639 \u064A\u0648\u0645",
    with: "\u0645\u0639",
    additional_date: "\u062A\u0627\u0631\u064A\u062E \u0625\u0636\u0627\u0641\u064A",
    additional_dates: "\u062A\u0648\u0627\u0631\u064A\u062E \u0625\u0636\u0627\u0641\u064A\u0629",
    excluding: "\u0628\u0627\u0633\u062A\u062B\u0646\u0627\u0621",
    date: "\u062A\u0627\u0631\u064A\u062E",
    dates: "\u062A\u0648\u0627\u0631\u064A\u062E",
    and: "\u0648",
    last: "\u0627\u0644\u0623\u062E\u064A\u0631"
  },
  ordinal: (n) => {
    if (n < 0) return "\u0627\u0644\u0623\u062E\u064A\u0631";
    const abs = Math.abs(n);
    const map = {
      1: "\u0627\u0644\u0623\u0648\u0644",
      2: "\u0627\u0644\u062B\u0627\u0646\u064A",
      3: "\u0627\u0644\u062B\u0627\u0644\u062B",
      4: "\u0627\u0644\u0631\u0627\u0628\u0639",
      5: "\u0627\u0644\u062E\u0627\u0645\u0633",
      6: "\u0627\u0644\u0633\u0627\u062F\u0633",
      7: "\u0627\u0644\u0633\u0627\u0628\u0639",
      8: "\u0627\u0644\u062B\u0627\u0645\u0646",
      9: "\u0627\u0644\u062A\u0627\u0633\u0639",
      10: "\u0627\u0644\u0639\u0627\u0634\u0631",
      11: "\u0627\u0644\u062D\u0627\u062F\u064A \u0639\u0634\u0631",
      12: "\u0627\u0644\u062B\u0627\u0646\u064A \u0639\u0634\u0631",
      13: "\u0627\u0644\u062B\u0627\u0644\u062B \u0639\u0634\u0631"
    };
    return map[abs] || abs.toString();
  }
};
var he = {
  weekdayNames: ["\u05D9\u05D5\u05DD \u05E9\u05E0\u05D9", "\u05D9\u05D5\u05DD \u05E9\u05DC\u05D9\u05E9\u05D9", "\u05D9\u05D5\u05DD \u05E8\u05D1\u05D9\u05E2\u05D9", "\u05D9\u05D5\u05DD \u05D7\u05DE\u05D9\u05E9\u05D9", "\u05D9\u05D5\u05DD \u05E9\u05D9\u05E9\u05D9", "\u05D9\u05D5\u05DD \u05E9\u05D1\u05EA", "\u05D9\u05D5\u05DD \u05E8\u05D0\u05E9\u05D5\u05DF"],
  monthNames: [
    "\u05D9\u05E0\u05D5\u05D0\u05E8",
    "\u05E4\u05D1\u05E8\u05D5\u05D0\u05E8",
    "\u05DE\u05E8\u05E5",
    "\u05D0\u05E4\u05E8\u05D9\u05DC",
    "\u05DE\u05D0\u05D9",
    "\u05D9\u05D5\u05E0\u05D9",
    "\u05D9\u05D5\u05DC\u05D9",
    "\u05D0\u05D5\u05D2\u05D5\u05E1\u05D8",
    "\u05E1\u05E4\u05D8\u05DE\u05D1\u05E8",
    "\u05D0\u05D5\u05E7\u05D8\u05D5\u05D1\u05E8",
    "\u05E0\u05D5\u05D1\u05DE\u05D1\u05E8",
    "\u05D3\u05E6\u05DE\u05D1\u05E8"
  ],
  units: {
    year: { singular: "\u05E9\u05E0\u05D4", plural: "\u05E9\u05E0\u05D9\u05DD" },
    month: { singular: "\u05D7\u05D5\u05D3\u05E9", plural: "\u05D7\u05D5\u05D3\u05E9\u05D9\u05DD" },
    week: { singular: "\u05E9\u05D1\u05D5\u05E2", plural: "\u05E9\u05D1\u05D5\u05E2\u05D5\u05EA" },
    day: { singular: "\u05D9\u05D5\u05DD", plural: "\u05D9\u05DE\u05D9\u05DD" },
    hour: { singular: "\u05E9\u05E2\u05D4", plural: "\u05E9\u05E2\u05D5\u05EA" },
    minute: { singular: "\u05D3\u05E7\u05D4", plural: "\u05D3\u05E7\u05D5\u05EA" },
    second: { singular: "\u05E9\u05E0\u05D9\u05D4", plural: "\u05E9\u05E0\u05D9\u05D5\u05EA" }
  },
  words: {
    every: "\u05DB\u05DC",
    weekday: "\u05D9\u05D5\u05DD \u05D7\u05D5\u05DC",
    on: "\u05D1",
    in: "\u05D1",
    on_the: "\u05D1",
    day_of_month: "\u05D9\u05D5\u05DD \u05D1\u05D7\u05D5\u05D3\u05E9",
    day_of_year: "\u05D9\u05D5\u05DD \u05D1\u05E9\u05E0\u05D4",
    in_week: "\u05D1\u05E9\u05D1\u05D5\u05E2",
    at: "\u05D1\u05E9\u05E2\u05D4",
    at_minute: "\u05D1\u05D3\u05E7\u05D4",
    at_second: "\u05D1\u05E9\u05E0\u05D9\u05D4",
    until: "\u05E2\u05D3",
    for: "\u05D1\u05DE\u05E9\u05DA",
    time: "\u05E4\u05E2\u05DD",
    times: "\u05E4\u05E2\u05DE\u05D9\u05DD",
    instance: "\u05E4\u05E2\u05DD",
    week_starts_on: "\u05E9\u05D1\u05D5\u05E2 \u05DE\u05EA\u05D7\u05D9\u05DC \u05D1",
    with: "\u05E2\u05DD",
    additional_date: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05E0\u05D5\u05E1\u05E3",
    additional_dates: "\u05EA\u05D0\u05E8\u05D9\u05DB\u05D9\u05DD \u05E0\u05D5\u05E1\u05E4\u05D9\u05DD",
    excluding: "\u05DC\u05DE\u05E2\u05D8",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA",
    dates: "\u05EA\u05D0\u05E8\u05D9\u05DB\u05D9\u05DD",
    and: "\u05D5",
    last: "\u05D0\u05D7\u05E8\u05D5\u05DF"
  },
  ordinal: (n) => {
    if (n < 0) return "\u05D0\u05D7\u05E8\u05D5\u05DF";
    const abs = Math.abs(n);
    const map = {
      1: "\u05E8\u05D0\u05E9\u05D5\u05DF",
      2: "\u05E9\u05E0\u05D9",
      3: "\u05E9\u05DC\u05D9\u05E9\u05D9",
      4: "\u05E8\u05D1\u05D9\u05E2\u05D9",
      5: "\u05D7\u05DE\u05D9\u05E9\u05D9",
      6: "\u05E9\u05D9\u05E9\u05D9",
      7: "\u05E9\u05D1\u05D9\u05E2\u05D9",
      8: "\u05E9\u05DE\u05D9\u05E0\u05D9",
      9: "\u05EA\u05E9\u05D9\u05E2\u05D9",
      10: "\u05E2\u05E9\u05D9\u05E8\u05D9",
      11: "\u05D0\u05D7\u05D3 \u05E2\u05E9\u05E8",
      12: "\u05E9\u05E0\u05D9\u05DD \u05E2\u05E9\u05E8",
      13: "\u05E9\u05DC\u05D5\u05E9\u05D4 \u05E2\u05E9\u05E8"
    };
    return map[abs] || abs.toString();
  }
};
var zh = {
  weekdayNames: ["\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D", "\u661F\u671F\u65E5"],
  monthNames: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"],
  units: {
    year: { singular: "\u5E74", plural: "\u5E74" },
    month: { singular: "\u6708", plural: "\u6708" },
    week: { singular: "\u5468", plural: "\u5468" },
    day: { singular: "\u65E5", plural: "\u65E5" },
    hour: { singular: "\u5C0F\u65F6", plural: "\u5C0F\u65F6" },
    minute: { singular: "\u5206\u949F", plural: "\u5206\u949F" },
    second: { singular: "\u79D2", plural: "\u79D2" }
  },
  words: {
    every: "\u6BCF",
    weekday: "\u5DE5\u4F5C\u65E5",
    on: "\u5728",
    in: "\u5728",
    on_the: "\u5728",
    day_of_month: "\u6708\u7684\u65E5\u5B50",
    day_of_year: "\u5E74\u7684\u65E5\u5B50",
    in_week: "\u7B2C",
    at: "\u5728",
    at_minute: "\u5728\u7B2C",
    at_second: "\u5728\u7B2C",
    until: "\u76F4\u5230",
    for: "\u5171",
    time: "\u6B21",
    times: "\u6B21",
    instance: "\u6B21",
    week_starts_on: "\u661F\u671F\u5F00\u59CB\u4E8E",
    with: "\u5E26\u6709",
    additional_date: "\u989D\u5916\u65E5\u671F",
    additional_dates: "\u989D\u5916\u65E5\u671F",
    excluding: "\u6392\u9664",
    date: "\u65E5\u671F",
    dates: "\u65E5\u671F",
    and: "\u548C",
    last: "\u6700\u540E"
  },
  ordinal: (n) => n < 0 ? "\u6700\u540E" : `\u7B2C${Math.abs(n)}`
};
var fr = {
  weekdayNames: ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi", "Dimanche"],
  monthNames: [
    "Janvier",
    "F\xE9vrier",
    "Mars",
    "Avril",
    "Mai",
    "Juin",
    "Juillet",
    "Ao\xFBt",
    "Septembre",
    "Octobre",
    "Novembre",
    "D\xE9cembre"
  ],
  units: {
    year: { singular: "ann\xE9e", plural: "ans" },
    month: { singular: "mois", plural: "mois" },
    week: { singular: "semaine", plural: "semaines" },
    day: { singular: "jour", plural: "jours" },
    hour: { singular: "heure", plural: "heures" },
    minute: { singular: "minute", plural: "minutes" },
    second: { singular: "seconde", plural: "secondes" }
  },
  words: {
    every: "chaque",
    weekday: "jour de semaine",
    on: "le",
    in: "dans",
    on_the: "le",
    day_of_month: "jour du mois",
    day_of_year: "jour de l'ann\xE9e",
    in_week: "dans la semaine",
    at: "\xE0",
    at_minute: "\xE0 la minute",
    at_second: "\xE0 la seconde",
    until: "jusqu'\xE0",
    for: "pendant",
    time: "fois",
    times: "fois",
    instance: "occurrence",
    week_starts_on: "la semaine commence le",
    with: "avec",
    additional_date: "date suppl\xE9mentaire",
    additional_dates: "dates suppl\xE9mentaires",
    excluding: "en excluant",
    date: "date",
    dates: "dates",
    and: "et",
    last: "dernier"
  },
  ordinal: (n) => {
    const abs = Math.abs(n);
    if (n < 0) return "dernier";
    if (abs === 1) return "1er";
    return `${abs}e`;
  }
};
var ALL_LOCALES = { en, de, es, hi, yue, ar, he, zh, fr };
var env = typeof process !== "undefined" && process.env ? process.env.TOTEXT_LANGS : void 0;
var active = env ? env.split(",").map((s) => s.trim()).filter(Boolean) : Object.keys(ALL_LOCALES);
var LOCALES = {};
for (const l of active) {
  if (ALL_LOCALES[l]) LOCALES[l] = ALL_LOCALES[l];
}
function defaultOrdinal(n) {
  const abs = Math.abs(n);
  const suffix = abs % 10 === 1 && abs % 100 !== 11 ? "st" : abs % 10 === 2 && abs % 100 !== 12 ? "nd" : abs % 10 === 3 && abs % 100 !== 13 ? "rd" : "th";
  return n < 0 ? `last` : `${abs}${suffix}`;
}
function ordinal(n, locale) {
  return locale.ordinal ? locale.ordinal(n) : defaultOrdinal(n);
}
function list(arr, mapFn = (x) => `${x}`, final) {
  const mapped = arr.map(mapFn);
  if (mapped.length === 1) return mapped[0];
  return mapped.slice(0, -1).join(", ") + ` ${final} ` + mapped[mapped.length - 1];
}
function formatByDayToken(tok, locale) {
  if (typeof tok === "number") return tok.toString();
  const m = tok.match(/^([+-]?\d+)?(MO|TU|WE|TH|FR|SA|SU)$/);
  if (!m) return tok;
  const ord = m[1] ? parseInt(m[1], 10) : 0;
  const weekdayMap = {
    MO: 0,
    TU: 1,
    WE: 2,
    TH: 3,
    FR: 4,
    SA: 5,
    SU: 6
  };
  const idx = weekdayMap[m[2]];
  const name = locale.weekdayNames[idx];
  if (ord === 0) return name;
  if (ord === -1) return `${locale.words.last} ${name}`;
  return `${ordinal(ord, locale)} ${name}`;
}
function formatTime(hour, minute = 0, second = 0) {
  const hr12 = (hour + 11) % 12 + 1;
  const ampm = hour < 12 ? "AM" : "PM";
  const mm = String(minute).padStart(2, "0");
  const ss = String(second).padStart(2, "0");
  if (second) {
    return `${hr12}:${mm}:${ss} ${ampm}`;
  }
  if (minute) {
    return `${hr12}:${mm} ${ampm}`;
  }
  return `${hr12} ${ampm}`;
}
function tzAbbreviation(zdt) {
  const parts = new Intl.DateTimeFormat("en-US", {
    timeZone: zdt.timeZoneId,
    timeZoneName: "short",
    hour: "numeric"
  }).formatToParts(new Date(zdt.epochMilliseconds));
  const tzPart = parts.find((p) => p.type === "timeZoneName");
  return (tzPart == null ? void 0 : tzPart.value) || zdt.timeZoneId;
}
function toText(input, locale) {
  const rule = typeof input === "string" ? new RRuleTemporal({ rruleString: input }) : input;
  const opts = rule.options();
  const lang = (locale != null ? locale : Intl.DateTimeFormat().resolvedOptions().locale).split("-")[0];
  const data = LOCALES[lang] || en;
  const {
    freq,
    interval = 1,
    count,
    until,
    byDay,
    byHour,
    byMinute,
    bySecond,
    byMonth,
    byMonthDay,
    byYearDay,
    byWeekNo,
    bySetPos,
    wkst,
    rDate,
    exDate
  } = opts;
  const parts = [data.words.every];
  const baseKey = {
    YEARLY: "year",
    MONTHLY: "month",
    WEEKLY: "week",
    DAILY: "day",
    HOURLY: "hour",
    MINUTELY: "minute",
    SECONDLY: "second"
  }[freq];
  const base = data.units[baseKey];
  const daysNormalized = byDay == null ? void 0 : byDay.map((d) => d.toUpperCase());
  const isWeekdays = daysNormalized && daysNormalized.length === 5 && ["MO", "TU", "WE", "TH", "FR"].every((d) => daysNormalized.includes(d));
  const isEveryday = daysNormalized && daysNormalized.length === 7 && ["MO", "TU", "WE", "TH", "FR", "SA", "SU"].every((d) => daysNormalized.includes(d));
  if (freq === "WEEKLY" && interval === 1 && isWeekdays) {
    parts.push(data.words.weekday);
  } else if (freq === "WEEKLY" && interval === 1 && isEveryday) {
    parts.push(data.units.day.singular);
  } else {
    if (interval !== 1) {
      parts.push(interval.toString(), base.plural);
    } else {
      parts.push(base.singular);
    }
  }
  if (freq === "WEEKLY" && byDay && !isWeekdays && !isEveryday) {
    parts.push(
      data.words.on,
      list(byDay, (t) => formatByDayToken(t, data), data.words.and)
    );
  } else if (byDay && freq !== "WEEKLY") {
    parts.push(
      data.words.on,
      list(byDay, (t) => formatByDayToken(t, data), data.words.and)
    );
  }
  if (byMonth) {
    parts.push(
      data.words.in,
      list(byMonth, (m) => data.monthNames[m - 1], data.words.and)
    );
  }
  if (byMonthDay) {
    parts.push(
      data.words.on_the,
      list(byMonthDay, (d) => ordinal(d, data), data.words.and),
      data.words.day_of_month
    );
  }
  if (byYearDay) {
    parts.push(
      data.words.on_the,
      list(byYearDay, (d) => ordinal(d, data), data.words.and),
      data.words.day_of_year
    );
  }
  if (byWeekNo) {
    parts.push(
      data.words.in_week,
      list(byWeekNo, (n) => n.toString(), data.words.and)
    );
  }
  if (byHour) {
    const minutes = byMinute != null ? byMinute : [0];
    const seconds = bySecond != null ? bySecond : [0];
    const times = byHour.flatMap((h) => minutes.flatMap((m) => seconds.map((s) => formatTime(h, m, s))));
    parts.push(data.words.at, list(times, void 0, data.words.and));
    parts.push(tzAbbreviation(opts.dtstart));
  }
  if (!byHour && byMinute) {
    parts.push(data.words.at_minute, list(byMinute, void 0, data.words.and));
  }
  if (!byHour && !byMinute && bySecond) {
    parts.push(data.words.at_second, list(bySecond, void 0, data.words.and));
  }
  if (until) {
    const monthName = data.monthNames[until.month - 1];
    parts.push(data.words.until, `${monthName} ${until.day}, ${until.year}`);
  } else if (count !== void 0) {
    parts.push(data.words.for, count.toString(), count === 1 ? data.words.time : data.words.times);
  }
  if (bySetPos) {
    parts.push(
      data.words.on_the,
      list(bySetPos, (n) => ordinal(n, data), data.words.and),
      data.words.instance
    );
  }
  if (wkst) {
    const wkName = formatByDayToken(wkst, data);
    parts.push(data.words.week_starts_on, wkName);
  }
  if (rDate && rDate.length) {
    parts.push(
      data.words.with,
      `${rDate.length}`,
      rDate.length === 1 ? data.words.additional_date : data.words.additional_dates
    );
  }
  if (exDate && exDate.length) {
    parts.push(data.words.excluding, `${exDate.length}`, exDate.length === 1 ? data.words.date : data.words.dates);
  }
  if (opts.rscale) {
    const rscale = opts.rscale;
    const skip = opts.skip;
    parts.push(`(RSCALE=${rscale}${skip ? `;SKIP=${skip}` : ""})`);
  }
  return parts.join(" ");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  toText
});
